<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx的反向代理与负载均衡</title>
      <link href="/posts/nginx.html"/>
      <url>/posts/nginx.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是反向代理与负载均衡"><a href="#一、什么是反向代理与负载均衡" class="headerlink" title="一、什么是反向代理与负载均衡"></a>一、什么是反向代理与负载均衡</h1><h4 id="①-反向代理"><a href="#①-反向代理" class="headerlink" title="① 反向代理"></a>① 反向代理</h4><p>我们有时候，用自己的计算机 A 想访问国外的某个网站 B，但是访问不了，此时，有一台中间服务器 C 可以访问国外的网站 B，那么，我们可以用自己的电脑访问服务器 C，通过 C 来访问 B 这个网站。那么这个时候，服务器 C 称为代理服务器，这种访问方式叫做正向代理。正向代理有一个特点，就是我们明确知道要访问哪个网站。再如，当我们有一个服务器集中，并且服务器集群中的每台服务器的内容一样的时候，同样我们要直接从个人电脑访问到服务器集中的服务器的时候无法访问，且此时第三方服务器能访问集群，这个时候，我们通过第三方服务器访问服务器集群的内容，但是比时我们并不知道是哪一台服务器提供的内容，此时的代理方式称为反向代理。</p><h4 id="②-负载均衡"><a href="#②-负载均衡" class="headerlink" title="② 负载均衡"></a>② 负载均衡</h4><p>当一台服务器的单位时间内的访问量越大的时候，服务器的压力会越大。当一台服务器压力大得超过自身的承受能力的时候，服务器会崩溃。为了避免服务器崩溃，让用户有更好地体验，我们通常通过负载均衡的方式来分担服务器的压力。那么什么是负载均衡呢？是这样，我们可以建立很多很多个服务器，这些服务器组成一个服务器集群，然后，当用户访问我们网站的时候，先访问一个中间服务器，再让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该选择的服务器。这样，用户的每次访问，都会保证服务器集群中的每个服务器的压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情況。</p><h1 id="二、Nginx-负载均衡的实现"><a href="#二、Nginx-负载均衡的实现" class="headerlink" title="二、Nginx 负载均衡的实现"></a>二、Nginx 负载均衡的实现</h1><p>Nginx 是一款可以通过反向代理实现负载均衡的服务器，使用 Nginx 服务实现负载均衡的时候，用户的访问首先会访问到 Nginx 服务器，然后 Nginx 服务器再从服务器集群表中选择压力较小的服务器，然后将该访问请求引向该服务器。若服务器集群中的某个服务器崩溃，那么从待选服务器列表中将该服务器删除，也就是说一个服务器假如崩溃了，那么 Nginx 就肯定不会将访门请求引 1 入该服务器了。</p><h1 id="三、HTTP-Upstream-模块"><a href="#三、HTTP-Upstream-模块" class="headerlink" title="三、HTTP Upstream 模块"></a>三、HTTP Upstream 模块</h1><p>Upstream 模块是 Nginx 服务器的一个重要模块。Upstream 模块实现在轮询和客户端 ip 之间实现后端的负载均衡。常用的指令有 ip_hash 指令、server 指令和 upstream 指令等，下面我们分别来讲一下。<br><strong>ip_hash：</strong><br>在负载均衡系统中，假如用户在某台服务器上登录，那么如果该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的一个服务器，那么此时如果将已经登录服务器 A 的用户再定位到其他服务器，显然不妥。故而，我们可以采用 ip_hash 指令解决这个问题，如果客户端请求已经访问了服务器 A 并登录，那么第二次请求的时候，会将该请求通过哈希算法自动定位到该后端服务器中。<br><strong>server 指令：</strong><br>server 指令主要用于指定服务器的名称和参数。<br><strong>upstream 指令：</strong><br>upstream 指令主要是用手设置一组可以在 proxy_pass 和 fastcgi_pass 指令中使用代理服务器，默认负载均衡方式为轮询。</p><h1 id="四、其他负载均衡的方法"><a href="#四、其他负载均衡的方法" class="headerlink" title="四、其他负载均衡的方法"></a>四、其他负载均衡的方法</h1><p>负载均衡的实现方法除了可以使用Nginx服务器实现外，还可以通过很多种方法来实现。负载均衡的核心就是建立一个服务器集群，然后用户首先访问到第三方代理服务器，然后由代理服务器选择一个集群中的服务器，然后将请求引入选定的服务器。那么代理服务器可以使用多种方式来充当，故而实现负载均衡的方式也是多种。总的来说，负载均衡实现的方式分为软件实现和硬件实现两种，如果中间的代理机构是硬件，那么就是通过硬件设备来实现负载均衡的方式，如果中间的代理机构为软件，就是软件实现负载均衡的方式。而其中，软件又可以是服务器软件、 系统软件以及应用软件等充当。</p><h1 id="五、负载均衡实现方式小结"><a href="#五、负载均衡实现方式小结" class="headerlink" title="五、负载均衡实现方式小结"></a>五、负载均衡实现方式小结</h1><p>下面我们简单总结一下负载均衡不同实现方式的优缺点：假如使用硬件的方式实现负载均衡，那么中间的转发机构就是硬件，这个时候运行的效率非常高，但是对应的成本也非常高。如果我们采用软件的方式来实现负载均衡，那么中间的转发机构就是软件，这个时候运行效率不如硬件，但是成本相对来说低得多。而使用Nginx服务器实现负载均衡，那么就是通过软件的方式来实现负载均衡，并旦Nginx本身支持高并发等。故而使用Nginx服务器实现负载均衡，能大大节约企业的成本，并且由于Nginx是服务器软件，其执行效率也是非常高。</p><h1 id="六、部署NodeJS上线步骤"><a href="#六、部署NodeJS上线步骤" class="headerlink" title="六、部署NodeJS上线步骤"></a>六、部署NodeJS上线步骤</h1><ul><li>1.打开https:l&#x2F;orew.sh&#x2F;index_ zh-cn.html</li><li>2.brew search nginx brew install nginx</li><li>3.brew info nginx </li><li>4.nginx -v  查看nginx信息</li><li>5.启动sudo brew services start nginx(默认端口8080）<br>备注：如果你安装过Jenkins的话这里失效</li><li>sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;ora.jenkins-ci.plist</li><li>systemctl start jenkins</li><li>6.关闭sudo brew services stop nginx &#x2F; nginx</li><li>7.nginx -s reload 、nginx -s stop</li><li>8.打开Nginx具体安装目录 查看配置文件 &#x2F;usrlocal&#x2F;etc&#x2F;nginx&#x2F;</li><li>9.验证配置文件 nginx-t-c 自己的配置文件地址</li><li>10.拷贝配置文件至Node 项目目录 重新修改</li><li>11.服务器端的 nginx地址</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发从基础到实战</title>
      <link href="/posts/miniprogram.html"/>
      <url>/posts/miniprogram.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、【微信小程序】开发起步"><a href="#一、【微信小程序】开发起步" class="headerlink" title="一、【微信小程序】开发起步"></a>一、【微信小程序】开发起步</h2><h3 id="1-1-小程序简介"><a href="#1-1-小程序简介" class="headerlink" title="1.1 小程序简介"></a>1.1 小程序简介</h3><h3 id="1-2-开发入门"><a href="#1-2-开发入门" class="headerlink" title="1.2 开发入门"></a>1.2 开发入门</h3><h2 id="二、【微信小程序】电影推荐案例实现①"><a href="#二、【微信小程序】电影推荐案例实现①" class="headerlink" title="二、【微信小程序】电影推荐案例实现①"></a>二、【微信小程序】电影推荐案例实现①</h2><h3 id="2-1-创建项目实现小程序介绍页"><a href="#2-1-创建项目实现小程序介绍页" class="headerlink" title="2.1 创建项目实现小程序介绍页"></a>2.1 创建项目实现小程序介绍页</h3><h3 id="2-2-flex布局与屏幕适配"><a href="#2-2-flex布局与屏幕适配" class="headerlink" title="2.2 flex布局与屏幕适配"></a>2.2 flex布局与屏幕适配</h3><h3 id="2-3-实现电影推荐页"><a href="#2-3-实现电影推荐页" class="headerlink" title="2.3 实现电影推荐页"></a>2.3 实现电影推荐页</h3><h3 id="2-4-添加tabBar"><a href="#2-4-添加tabBar" class="headerlink" title="2.4 添加tabBar"></a>2.4 添加tabBar</h3><h3 id="2-5-电影推荐页绑定数据"><a href="#2-5-电影推荐页绑定数据" class="headerlink" title="2.5 电影推荐页绑定数据"></a>2.5 电影推荐页绑定数据</h3><h3 id="2-6-条件渲染与列表渲染"><a href="#2-6-条件渲染与列表渲染" class="headerlink" title="2.6 条件渲染与列表渲染"></a>2.6 条件渲染与列表渲染</h3><h3 id="2-7-电影列表轮播效果"><a href="#2-7-电影列表轮播效果" class="headerlink" title="2.7 电影列表轮播效果"></a>2.7 电影列表轮播效果</h3><h3 id="2-8-轮播翻页控制"><a href="#2-8-轮播翻页控制" class="headerlink" title="2.8 轮播翻页控制"></a>2.8 轮播翻页控制</h3><h3 id="2-9-数据更新与事件机制"><a href="#2-9-数据更新与事件机制" class="headerlink" title="2.9 数据更新与事件机制"></a>2.9 数据更新与事件机制</h3><h3 id="2-10-电影推荐页路由传参跳转"><a href="#2-10-电影推荐页路由传参跳转" class="headerlink" title="2.10 电影推荐页路由传参跳转"></a>2.10 电影推荐页路由传参跳转</h3><h2 id="三、【微信小程序】电影推荐案例实现②"><a href="#三、【微信小程序】电影推荐案例实现②" class="headerlink" title="三、【微信小程序】电影推荐案例实现②"></a>三、【微信小程序】电影推荐案例实现②</h2><h2 id="四、【微信小程序】上手云开发"><a href="#四、【微信小程序】上手云开发" class="headerlink" title="四、【微信小程序】上手云开发"></a>四、【微信小程序】上手云开发</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo遇到的问题</title>
      <link href="/posts/problem.html"/>
      <url>/posts/problem.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、解决Hexo-clean导致CNAME文件被删问题"><a href="#一、解决Hexo-clean导致CNAME文件被删问题" class="headerlink" title="一、解决Hexo clean导致CNAME文件被删问题"></a>一、解决Hexo clean导致CNAME文件被删问题</h2><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用<code>hexo clean</code>命令之后，<strong>public</strong>文件夹便会被删除，而我们一开始将自己的GitHub地址绑定到个人域名上的时候，是通过**&#x2F;public&#x2F;CNAME<strong>文件来实现映射的，所以</strong>&#x2F;public<strong>文件夹被删除，</strong>CNAME<strong>文件也将被删除，重新执行<code>hexo g</code>命令也不会重新生成</strong>CNAME**文件，所以通过域名就无法访问博客。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>这是因为整个**&#x2F;public<strong>文件夹是执行<code>hexo g</code>后生成的，若执行<code>hexo clean1</code>会把整个public连同CNAME文件夹删掉，在重新执行<code>hexo g</code>后生成的</strong>&#x2F;public<strong>文件夹里肯定没有我们手动添加的</strong>CNAME**文件。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决方法是把<strong>CNAME</strong>文件放在**&#x2F;source<strong>文件夹下，而不是</strong>&#x2F;public<strong>文件夹，在执行<code>hexo g</code>命令时，会把</strong>&#x2F;source<strong>文件夹下的</strong>CNAME<strong>文件原原本本地复制到</strong>&#x2F;public**文件夹下，即使执行<code>hexo clean</code>后，下次重新编译还是会复制过去，这样就解决了问题。</p><p>其实还有很多其他的文件如果想编译后放在**&#x2F;public<strong>文件夹下，都可以先放</strong>&#x2F;source<strong>文件夹下，在<code>hexo g</code>编译后就会复制到</strong>&#x2F;public**文件夹下。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的JavaScript(上卷)</title>
      <link href="/posts/javscript.html"/>
      <url>/posts/javscript.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h1><h2 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 作用域是什么"></a>第一章 作用域是什么</h2><p><strong>几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个值进行访问或修改。</strong></p><h3 id="1-1-编译原理"><a href="#1-1-编译原理" class="headerlink" title="1.1 编译原理"></a>1.1 编译原理</h3><h3 id="1-2-理解作用域小测验"><a href="#1-2-理解作用域小测验" class="headerlink" title="1.2 理解作用域小测验"></a>1.2 理解作用域小测验</h3><h4 id="1-2-1-演员表"><a href="#1-2-1-演员表" class="headerlink" title="1.2.1 演员表"></a>1.2.1 演员表</h4><h4 id="1-2-2-对话"><a href="#1-2-2-对话" class="headerlink" title="1.2.2 对话"></a>1.2.2 对话</h4><h4 id="1-2-3-编译器有话说"><a href="#1-2-3-编译器有话说" class="headerlink" title="1.2.3 编译器有话说"></a>1.2.3 编译器有话说</h4><h4 id="1-2-4-引擎和作用域的对话"><a href="#1-2-4-引擎和作用域的对话" class="headerlink" title="1.2.4 引擎和作用域的对话"></a>1.2.4 引擎和作用域的对话</h4><h4 id="1-2-5"><a href="#1-2-5" class="headerlink" title="1.2.5"></a>1.2.5</h4><h3 id="1-3-作用域嵌套"><a href="#1-3-作用域嵌套" class="headerlink" title="1.3 作用域嵌套"></a>1.3 作用域嵌套</h3><h3 id="1-4-异常"><a href="#1-4-异常" class="headerlink" title="1.4 异常"></a>1.4 异常</h3><h2 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h2><h1 id="第二部分-this和对象原型"><a href="#第二部分-this和对象原型" class="headerlink" title="第二部分 this和对象原型"></a>第二部分 this和对象原型</h1>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript设计模式与开发实践</title>
      <link href="/posts/designMode.html"/>
      <url>/posts/designMode.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分   基础知识"></a>第一部分   基础知识</h2><h3 id="1、面向对象的JavaScript"><a href="#1、面向对象的JavaScript" class="headerlink" title="1、面向对象的JavaScript"></a>1、面向对象的JavaScript</h3><h4 id="1-1-动态类型语言和鸭子类型"><a href="#1-1-动态类型语言和鸭子类型" class="headerlink" title="1.1 动态类型语言和鸭子类型"></a>1.1 动态类型语言和鸭子类型</h4><h4 id="1-2-多态"><a href="#1-2-多态" class="headerlink" title="1.2 多态"></a>1.2 多态</h4><h4 id="1-3-封装"><a href="#1-3-封装" class="headerlink" title="1.3 封装"></a>1.3 封装</h4><h4 id="1-4-原型模式和基于原型继承的JavaScript对象系统"><a href="#1-4-原型模式和基于原型继承的JavaScript对象系统" class="headerlink" title="1.4 原型模式和基于原型继承的JavaScript对象系统"></a>1.4 原型模式和基于原型继承的JavaScript对象系统</h4><h3 id="2、this、call和apply"><a href="#2、this、call和apply" class="headerlink" title="2、this、call和apply"></a>2、this、call和apply</h3><h4 id="2-1-this"><a href="#2-1-this" class="headerlink" title="2.1 this"></a>2.1 this</h4><h4 id="2-2-call和apply"><a href="#2-2-call和apply" class="headerlink" title="2.2 call和apply"></a>2.2 call和apply</h4><h3 id="3、闭包和高阶函数"><a href="#3、闭包和高阶函数" class="headerlink" title="3、闭包和高阶函数"></a>3、闭包和高阶函数</h3><h4 id="3-1-闭包"><a href="#3-1-闭包" class="headerlink" title="3.1 闭包"></a>3.1 闭包</h4><h4 id="3-2-高阶函数"><a href="#3-2-高阶函数" class="headerlink" title="3.2 高阶函数"></a>3.2 高阶函数</h4><h2 id="第二部分-设计模式"><a href="#第二部分-设计模式" class="headerlink" title="第二部分   设计模式"></a>第二部分   设计模式</h2><h3 id="4、单例模式"><a href="#4、单例模式" class="headerlink" title="4、单例模式"></a>4、单例模式</h3><h4 id="4-1-实现单例模式"><a href="#4-1-实现单例模式" class="headerlink" title="4.1 实现单例模式"></a>4.1 实现单例模式</h4><h4 id="4-2-透明的单例模式"><a href="#4-2-透明的单例模式" class="headerlink" title="4.2 透明的单例模式"></a>4.2 透明的单例模式</h4><h4 id="4-3-用代理实现单例模式"><a href="#4-3-用代理实现单例模式" class="headerlink" title="4.3 用代理实现单例模式"></a>4.3 用代理实现单例模式</h4><h4 id="4-4-JavaScript中的单例模式"><a href="#4-4-JavaScript中的单例模式" class="headerlink" title="4.4 JavaScript中的单例模式"></a>4.4 JavaScript中的单例模式</h4><h4 id="4-5-惰性单例"><a href="#4-5-惰性单例" class="headerlink" title="4.5 惰性单例"></a>4.5 惰性单例</h4><h4 id="4-6-通用的惰性单例"><a href="#4-6-通用的惰性单例" class="headerlink" title="4.6 通用的惰性单例"></a>4.6 通用的惰性单例</h4><h3 id="5、策略模式"><a href="#5、策略模式" class="headerlink" title="5、策略模式"></a>5、策略模式</h3><h4 id="5-1-使用策略模式计算奖金"><a href="#5-1-使用策略模式计算奖金" class="headerlink" title="5.1 使用策略模式计算奖金"></a>5.1 使用策略模式计算奖金</h4><h4 id="5-2-JavaScript版本的策略模式"><a href="#5-2-JavaScript版本的策略模式" class="headerlink" title="5.2 JavaScript版本的策略模式"></a>5.2 JavaScript版本的策略模式</h4><h4 id="5-3-多态在策略模式中的提现"><a href="#5-3-多态在策略模式中的提现" class="headerlink" title="5.3 多态在策略模式中的提现"></a>5.3 多态在策略模式中的提现</h4><h4 id="5-4-使用策略模式实现缓动动画"><a href="#5-4-使用策略模式实现缓动动画" class="headerlink" title="5.4 使用策略模式实现缓动动画"></a>5.4 使用策略模式实现缓动动画</h4><h4 id="5-5-更广义的“算法”"><a href="#5-5-更广义的“算法”" class="headerlink" title="5.5 更广义的“算法”"></a>5.5 更广义的“算法”</h4><h4 id="5-6-表单校验"><a href="#5-6-表单校验" class="headerlink" title="5.6 表单校验"></a>5.6 表单校验</h4><h4 id="5-7-策略模式的优缺点"><a href="#5-7-策略模式的优缺点" class="headerlink" title="5.7 策略模式的优缺点"></a>5.7 策略模式的优缺点</h4><h4 id="5-8-一等函数对象与策略模式"><a href="#5-8-一等函数对象与策略模式" class="headerlink" title="5.8 一等函数对象与策略模式"></a>5.8 一等函数对象与策略模式</h4><h3 id="6、代理模式"><a href="#6、代理模式" class="headerlink" title="6、代理模式"></a>6、代理模式</h3><h4 id="6-1-第一个例子————小明追MM的故事"><a href="#6-1-第一个例子————小明追MM的故事" class="headerlink" title="6.1 第一个例子————小明追MM的故事"></a>6.1 第一个例子————小明追MM的故事</h4><h4 id="6-2-保护代理和虚拟代理"><a href="#6-2-保护代理和虚拟代理" class="headerlink" title="6.2 保护代理和虚拟代理"></a>6.2 保护代理和虚拟代理</h4><h4 id="6-3-虚拟代理实现图片预加载"><a href="#6-3-虚拟代理实现图片预加载" class="headerlink" title="6.3 虚拟代理实现图片预加载"></a>6.3 虚拟代理实现图片预加载</h4><h4 id="6-4-代理的意义"><a href="#6-4-代理的意义" class="headerlink" title="6.4 代理的意义"></a>6.4 代理的意义</h4><h4 id="6-5-代理和本体接口的一致性"><a href="#6-5-代理和本体接口的一致性" class="headerlink" title="6.5 代理和本体接口的一致性"></a>6.5 代理和本体接口的一致性</h4><h4 id="6-6-虚拟代理合并HTTP请求"><a href="#6-6-虚拟代理合并HTTP请求" class="headerlink" title="6.6 虚拟代理合并HTTP请求"></a>6.6 虚拟代理合并HTTP请求</h4><h4 id="6-7-虚拟代理在惰性加载中的应用"><a href="#6-7-虚拟代理在惰性加载中的应用" class="headerlink" title="6.7 虚拟代理在惰性加载中的应用"></a>6.7 虚拟代理在惰性加载中的应用</h4><h4 id="6-8-缓存代理"><a href="#6-8-缓存代理" class="headerlink" title="6.8 缓存代理"></a>6.8 缓存代理</h4><h4 id="6-9-用高阶函数动态创建代理"><a href="#6-9-用高阶函数动态创建代理" class="headerlink" title="6.9 用高阶函数动态创建代理"></a>6.9 用高阶函数动态创建代理</h4><h4 id="6-10-其他代理模式"><a href="#6-10-其他代理模式" class="headerlink" title="6.10 其他代理模式"></a>6.10 其他代理模式</h4><h3 id="7、迭代器模式"><a href="#7、迭代器模式" class="headerlink" title="7、迭代器模式"></a>7、迭代器模式</h3><h4 id="7-1-jQuery中的迭代器"><a href="#7-1-jQuery中的迭代器" class="headerlink" title="7.1 jQuery中的迭代器"></a>7.1 jQuery中的迭代器</h4><h4 id="7-2-实现自己的迭代器"><a href="#7-2-实现自己的迭代器" class="headerlink" title="7.2 实现自己的迭代器"></a>7.2 实现自己的迭代器</h4><h4 id="7-3-内部迭代器和外部迭代器"><a href="#7-3-内部迭代器和外部迭代器" class="headerlink" title="7.3 内部迭代器和外部迭代器"></a>7.3 内部迭代器和外部迭代器</h4><h4 id="7-4-迭代类数组对象和字面量对象"><a href="#7-4-迭代类数组对象和字面量对象" class="headerlink" title="7.4 迭代类数组对象和字面量对象"></a>7.4 迭代类数组对象和字面量对象</h4><h4 id="7-5-倒序迭代器"><a href="#7-5-倒序迭代器" class="headerlink" title="7.5 倒序迭代器"></a>7.5 倒序迭代器</h4><h4 id="7-6-中止迭代器"><a href="#7-6-中止迭代器" class="headerlink" title="7.6 中止迭代器"></a>7.6 中止迭代器</h4><h4 id="7-7-迭代器模式的应用举例"><a href="#7-7-迭代器模式的应用举例" class="headerlink" title="7.7 迭代器模式的应用举例"></a>7.7 迭代器模式的应用举例</h4><h3 id="8、发布——订阅模式"><a href="#8、发布——订阅模式" class="headerlink" title="8、发布——订阅模式"></a>8、发布——订阅模式</h3><h4 id="8-1-现实中的发布——订阅模式"><a href="#8-1-现实中的发布——订阅模式" class="headerlink" title="8.1 现实中的发布——订阅模式"></a>8.1 现实中的发布——订阅模式</h4><h4 id="8-2-发布——订阅模式的作用"><a href="#8-2-发布——订阅模式的作用" class="headerlink" title="8.2 发布——订阅模式的作用"></a>8.2 发布——订阅模式的作用</h4><h4 id="8-3-DOM事件"><a href="#8-3-DOM事件" class="headerlink" title="8.3 DOM事件"></a>8.3 DOM事件</h4><h4 id="8-4-自定义事件"><a href="#8-4-自定义事件" class="headerlink" title="8.4 自定义事件"></a>8.4 自定义事件</h4><h4 id="8-5-发布——订阅模式的通用实现"><a href="#8-5-发布——订阅模式的通用实现" class="headerlink" title="8.5 发布——订阅模式的通用实现"></a>8.5 发布——订阅模式的通用实现</h4><h4 id="8-6-取消订阅的事件"><a href="#8-6-取消订阅的事件" class="headerlink" title="8.6 取消订阅的事件"></a>8.6 取消订阅的事件</h4><h4 id="8-7-真实的例子————网站登录"><a href="#8-7-真实的例子————网站登录" class="headerlink" title="8.7 真实的例子————网站登录"></a>8.7 真实的例子————网站登录</h4><h4 id="8-8-全局的发布——订阅对象"><a href="#8-8-全局的发布——订阅对象" class="headerlink" title="8.8 全局的发布——订阅对象"></a>8.8 全局的发布——订阅对象</h4><h4 id="8-9-模块间通信"><a href="#8-9-模块间通信" class="headerlink" title="8.9 模块间通信"></a>8.9 模块间通信</h4><h4 id="8-10-必须先订阅再发布吗"><a href="#8-10-必须先订阅再发布吗" class="headerlink" title="8.10 必须先订阅再发布吗"></a>8.10 必须先订阅再发布吗</h4><h4 id="8-11-全局事件的命名冲突"><a href="#8-11-全局事件的命名冲突" class="headerlink" title="8.11 全局事件的命名冲突"></a>8.11 全局事件的命名冲突</h4><h4 id="8-12-JavaScript实现发布——订阅模式的便利性"><a href="#8-12-JavaScript实现发布——订阅模式的便利性" class="headerlink" title="8.12 JavaScript实现发布——订阅模式的便利性"></a>8.12 JavaScript实现发布——订阅模式的便利性</h4><h3 id="9、命令模式"><a href="#9、命令模式" class="headerlink" title="9、命令模式"></a>9、命令模式</h3><h4 id="9-1-命令模式的用途"><a href="#9-1-命令模式的用途" class="headerlink" title="9.1 命令模式的用途"></a>9.1 命令模式的用途</h4><h4 id="9-2-命令模式的例子————菜单程序"><a href="#9-2-命令模式的例子————菜单程序" class="headerlink" title="9.2 命令模式的例子————菜单程序"></a>9.2 命令模式的例子————菜单程序</h4><h4 id="9-3-JavaScript中的命令模式"><a href="#9-3-JavaScript中的命令模式" class="headerlink" title="9.3 JavaScript中的命令模式"></a>9.3 JavaScript中的命令模式</h4><h4 id="9-4-撤销命令"><a href="#9-4-撤销命令" class="headerlink" title="9.4 撤销命令"></a>9.4 撤销命令</h4><h4 id="9-5-撤销和重做"><a href="#9-5-撤销和重做" class="headerlink" title="9.5 撤销和重做"></a>9.5 撤销和重做</h4><h4 id="9-6-命令队列"><a href="#9-6-命令队列" class="headerlink" title="9.6 命令队列"></a>9.6 命令队列</h4><h4 id="9-7-宏命令"><a href="#9-7-宏命令" class="headerlink" title="9.7 宏命令"></a>9.7 宏命令</h4><h4 id="9-8-智能命令与傻瓜命令"><a href="#9-8-智能命令与傻瓜命令" class="headerlink" title="9.8 智能命令与傻瓜命令"></a>9.8 智能命令与傻瓜命令</h4><h3 id="10、组合模式"><a href="#10、组合模式" class="headerlink" title="10、组合模式"></a>10、组合模式</h3><h4 id="10-1-回顾宏命令"><a href="#10-1-回顾宏命令" class="headerlink" title="10.1 回顾宏命令"></a>10.1 回顾宏命令</h4><h4 id="10-2-组合模式的用途"><a href="#10-2-组合模式的用途" class="headerlink" title="10.2 组合模式的用途"></a>10.2 组合模式的用途</h4><h4 id="10-3-请求在树中传递的过程"><a href="#10-3-请求在树中传递的过程" class="headerlink" title="10.3 请求在树中传递的过程"></a>10.3 请求在树中传递的过程</h4><h4 id="10-4-更强大的宏命令"><a href="#10-4-更强大的宏命令" class="headerlink" title="10.4 更强大的宏命令"></a>10.4 更强大的宏命令</h4><h4 id="10-5-抽象类在组合模式中的作用"><a href="#10-5-抽象类在组合模式中的作用" class="headerlink" title="10.5 抽象类在组合模式中的作用"></a>10.5 抽象类在组合模式中的作用</h4><h4 id="10-6-透明性带来的安全问题"><a href="#10-6-透明性带来的安全问题" class="headerlink" title="10.6 透明性带来的安全问题"></a>10.6 透明性带来的安全问题</h4><h4 id="10-7-组合模式的例子————扫描文件夹"><a href="#10-7-组合模式的例子————扫描文件夹" class="headerlink" title="10.7 组合模式的例子————扫描文件夹"></a>10.7 组合模式的例子————扫描文件夹</h4><h4 id="10-8-一些值得注意的地方"><a href="#10-8-一些值得注意的地方" class="headerlink" title="10.8 一些值得注意的地方"></a>10.8 一些值得注意的地方</h4><h4 id="10-9-引用父对象"><a href="#10-9-引用父对象" class="headerlink" title="10.9 引用父对象"></a>10.9 引用父对象</h4><h4 id="10-10-何时使用组合模式"><a href="#10-10-何时使用组合模式" class="headerlink" title="10.10 何时使用组合模式"></a>10.10 何时使用组合模式</h4><h3 id="11、模板方法模式"><a href="#11、模板方法模式" class="headerlink" title="11、模板方法模式"></a>11、模板方法模式</h3><h4 id="11-1-模板方法模式的定义和组成"><a href="#11-1-模板方法模式的定义和组成" class="headerlink" title="11.1 模板方法模式的定义和组成"></a>11.1 模板方法模式的定义和组成</h4><h4 id="11-2-第一个例子————Coffee-or-Tea"><a href="#11-2-第一个例子————Coffee-or-Tea" class="headerlink" title="11.2 第一个例子————Coffee or Tea"></a>11.2 第一个例子————Coffee or Tea</h4><h4 id="11-3-抽象类"><a href="#11-3-抽象类" class="headerlink" title="11.3 抽象类"></a>11.3 抽象类</h4><h4 id="11-4-模板方法模式的使用场景"><a href="#11-4-模板方法模式的使用场景" class="headerlink" title="11.4 模板方法模式的使用场景"></a>11.4 模板方法模式的使用场景</h4><h4 id="11-5-钩子方法"><a href="#11-5-钩子方法" class="headerlink" title="11.5 钩子方法"></a>11.5 钩子方法</h4><h4 id="11-6-好莱坞原则"><a href="#11-6-好莱坞原则" class="headerlink" title="11.6 好莱坞原则"></a>11.6 好莱坞原则</h4><h4 id="11-7-真的需要“继承”吗"><a href="#11-7-真的需要“继承”吗" class="headerlink" title="11.7 真的需要“继承”吗"></a>11.7 真的需要“继承”吗</h4><h3 id="12、享元模式"><a href="#12、享元模式" class="headerlink" title="12、享元模式"></a>12、享元模式</h3><h4 id="12-1-初识享元模式"><a href="#12-1-初识享元模式" class="headerlink" title="12.1 初识享元模式"></a>12.1 初识享元模式</h4><h4 id="12-2-内部状态与外部状态"><a href="#12-2-内部状态与外部状态" class="headerlink" title="12.2 内部状态与外部状态"></a>12.2 内部状态与外部状态</h4><h4 id="12-3-享元模式的通用结构"><a href="#12-3-享元模式的通用结构" class="headerlink" title="12.3 享元模式的通用结构"></a>12.3 享元模式的通用结构</h4><h4 id="12-4-文件上传的例子"><a href="#12-4-文件上传的例子" class="headerlink" title="12.4 文件上传的例子"></a>12.4 文件上传的例子</h4><h4 id="12-5-享元模式的适用性"><a href="#12-5-享元模式的适用性" class="headerlink" title="12.5 享元模式的适用性"></a>12.5 享元模式的适用性</h4><h4 id="12-6-再谈内部状态和外部状态"><a href="#12-6-再谈内部状态和外部状态" class="headerlink" title="12.6 再谈内部状态和外部状态"></a>12.6 再谈内部状态和外部状态</h4><h4 id="12-7-对象池"><a href="#12-7-对象池" class="headerlink" title="12.7 对象池"></a>12.7 对象池</h4><h3 id="13、职责链模式"><a href="#13、职责链模式" class="headerlink" title="13、职责链模式"></a>13、职责链模式</h3><h4 id="13-1-现实中的职责链模式"><a href="#13-1-现实中的职责链模式" class="headerlink" title="13.1 现实中的职责链模式"></a>13.1 现实中的职责链模式</h4><h4 id="13-2-实际开发中的职责链模式"><a href="#13-2-实际开发中的职责链模式" class="headerlink" title="13.2 实际开发中的职责链模式"></a>13.2 实际开发中的职责链模式</h4><h4 id="13-3-用职责链模式重构代码"><a href="#13-3-用职责链模式重构代码" class="headerlink" title="13.3 用职责链模式重构代码"></a>13.3 用职责链模式重构代码</h4><h4 id="13-4-灵活可拆分的职责链节点"><a href="#13-4-灵活可拆分的职责链节点" class="headerlink" title="13.4 灵活可拆分的职责链节点"></a>13.4 灵活可拆分的职责链节点</h4><h4 id="13-5-异步的职责链"><a href="#13-5-异步的职责链" class="headerlink" title="13.5 异步的职责链"></a>13.5 异步的职责链</h4><h4 id="13-6-职责链模式的优缺点"><a href="#13-6-职责链模式的优缺点" class="headerlink" title="13.6 职责链模式的优缺点"></a>13.6 职责链模式的优缺点</h4><h4 id="13-7-用AOP实现职责链"><a href="#13-7-用AOP实现职责链" class="headerlink" title="13.7 用AOP实现职责链"></a>13.7 用AOP实现职责链</h4><h4 id="13-8-用职责链模式获取文件上传对象"><a href="#13-8-用职责链模式获取文件上传对象" class="headerlink" title="13.8 用职责链模式获取文件上传对象"></a>13.8 用职责链模式获取文件上传对象</h4><h3 id="14、中介者模式"><a href="#14、中介者模式" class="headerlink" title="14、中介者模式"></a>14、中介者模式</h3><h4 id="14-1-现实中的中介者"><a href="#14-1-现实中的中介者" class="headerlink" title="14.1 现实中的中介者"></a>14.1 现实中的中介者</h4><h4 id="14-2-中介者模式的例子————泡泡堂游戏"><a href="#14-2-中介者模式的例子————泡泡堂游戏" class="headerlink" title="14.2 中介者模式的例子————泡泡堂游戏"></a>14.2 中介者模式的例子————泡泡堂游戏</h4><h4 id="14-3-中介者模式的例子————购买商品"><a href="#14-3-中介者模式的例子————购买商品" class="headerlink" title="14.3 中介者模式的例子————购买商品"></a>14.3 中介者模式的例子————购买商品</h4><h3 id="15、装饰者模式"><a href="#15、装饰者模式" class="headerlink" title="15、装饰者模式"></a>15、装饰者模式</h3><h4 id="15-1-模拟传统面向对象语言的装饰者模式"><a href="#15-1-模拟传统面向对象语言的装饰者模式" class="headerlink" title="15.1 模拟传统面向对象语言的装饰者模式"></a>15.1 模拟传统面向对象语言的装饰者模式</h4><h4 id="15-2-装饰者也是包装器"><a href="#15-2-装饰者也是包装器" class="headerlink" title="15.2 装饰者也是包装器"></a>15.2 装饰者也是包装器</h4><h4 id="15-3-回到JavaScript的装饰器"><a href="#15-3-回到JavaScript的装饰器" class="headerlink" title="15.3 回到JavaScript的装饰器"></a>15.3 回到JavaScript的装饰器</h4><h4 id="15-4-装饰函数"><a href="#15-4-装饰函数" class="headerlink" title="15.4 装饰函数"></a>15.4 装饰函数</h4><h4 id="15-5-用AOP装饰函数"><a href="#15-5-用AOP装饰函数" class="headerlink" title="15.5 用AOP装饰函数"></a>15.5 用AOP装饰函数</h4><h4 id="15-6-AOP的应用实例"><a href="#15-6-AOP的应用实例" class="headerlink" title="15.6 AOP的应用实例"></a>15.6 AOP的应用实例</h4><h4 id="15-7-装饰者模式和代理模式"><a href="#15-7-装饰者模式和代理模式" class="headerlink" title="15.7 装饰者模式和代理模式"></a>15.7 装饰者模式和代理模式</h4><h3 id="16、状态模式"><a href="#16、状态模式" class="headerlink" title="16、状态模式"></a>16、状态模式</h3><h4 id="16-1-初识状态模式"><a href="#16-1-初识状态模式" class="headerlink" title="16.1 初识状态模式"></a>16.1 初识状态模式</h4><h4 id="16-2-状态模式的定义"><a href="#16-2-状态模式的定义" class="headerlink" title="16.2 状态模式的定义"></a>16.2 状态模式的定义</h4><h4 id="16-3-状态模式的通用结构"><a href="#16-3-状态模式的通用结构" class="headerlink" title="16.3 状态模式的通用结构"></a>16.3 状态模式的通用结构</h4><h4 id="16-4-缺少抽象类的变通方式"><a href="#16-4-缺少抽象类的变通方式" class="headerlink" title="16.4 缺少抽象类的变通方式"></a>16.4 缺少抽象类的变通方式</h4><h4 id="16-5-另一个状态模式示例————文件上传"><a href="#16-5-另一个状态模式示例————文件上传" class="headerlink" title="16.5 另一个状态模式示例————文件上传"></a>16.5 另一个状态模式示例————文件上传</h4><h4 id="16-6-状态模式的优缺点"><a href="#16-6-状态模式的优缺点" class="headerlink" title="16.6 状态模式的优缺点"></a>16.6 状态模式的优缺点</h4><h4 id="16-7-状态模式中的性能优缺点"><a href="#16-7-状态模式中的性能优缺点" class="headerlink" title="16.7 状态模式中的性能优缺点"></a>16.7 状态模式中的性能优缺点</h4><h4 id="16-8-状态模式和策略模式的关系"><a href="#16-8-状态模式和策略模式的关系" class="headerlink" title="16.8 状态模式和策略模式的关系"></a>16.8 状态模式和策略模式的关系</h4><h4 id="16-9-JavaScript版本的状态机"><a href="#16-9-JavaScript版本的状态机" class="headerlink" title="16.9 JavaScript版本的状态机"></a>16.9 JavaScript版本的状态机</h4><h4 id="16-10-表驱动的有限状态机"><a href="#16-10-表驱动的有限状态机" class="headerlink" title="16.10 表驱动的有限状态机"></a>16.10 表驱动的有限状态机</h4><h4 id="16-11-实际项目中的其他状态机"><a href="#16-11-实际项目中的其他状态机" class="headerlink" title="16.11 实际项目中的其他状态机"></a>16.11 实际项目中的其他状态机</h4><h3 id="17、适配器模式"><a href="#17、适配器模式" class="headerlink" title="17、适配器模式"></a>17、适配器模式</h3><h4 id="17-1-现实中的适配器"><a href="#17-1-现实中的适配器" class="headerlink" title="17.1 现实中的适配器"></a>17.1 现实中的适配器</h4><h4 id="17-2-适配器模式的应用"><a href="#17-2-适配器模式的应用" class="headerlink" title="17.2 适配器模式的应用"></a>17.2 适配器模式的应用</h4><h2 id="第三部分-设计原则和编程技巧"><a href="#第三部分-设计原则和编程技巧" class="headerlink" title="第三部分   设计原则和编程技巧"></a>第三部分   设计原则和编程技巧</h2><h3 id="18、单一职责原则"><a href="#18、单一职责原则" class="headerlink" title="18、单一职责原则"></a>18、单一职责原则</h3><h4 id="18-1-设计模式中的SRP原则"><a href="#18-1-设计模式中的SRP原则" class="headerlink" title="18.1 设计模式中的SRP原则"></a>18.1 设计模式中的SRP原则</h4><h4 id="18-2-何时应该分离职责"><a href="#18-2-何时应该分离职责" class="headerlink" title="18.2 何时应该分离职责"></a>18.2 何时应该分离职责</h4><h4 id="18-3-违反SRP原则"><a href="#18-3-违反SRP原则" class="headerlink" title="18.3 违反SRP原则"></a>18.3 违反SRP原则</h4><h4 id="18-4-SRP原则的优缺点"><a href="#18-4-SRP原则的优缺点" class="headerlink" title="18.4 SRP原则的优缺点"></a>18.4 SRP原则的优缺点</h4><h3 id="19、最少知识原则"><a href="#19、最少知识原则" class="headerlink" title="19、最少知识原则"></a>19、最少知识原则</h3><h4 id="19-1-减少对象之间的联系"><a href="#19-1-减少对象之间的联系" class="headerlink" title="19.1 减少对象之间的联系"></a>19.1 减少对象之间的联系</h4><h4 id="19-2-设计模式中的LKP原则"><a href="#19-2-设计模式中的LKP原则" class="headerlink" title="19.2 设计模式中的LKP原则"></a>19.2 设计模式中的LKP原则</h4><h4 id="19-3-封装在LKP原则中的体现"><a href="#19-3-封装在LKP原则中的体现" class="headerlink" title="19.3 封装在LKP原则中的体现"></a>19.3 封装在LKP原则中的体现</h4><h3 id="20、开放-封闭原则"><a href="#20、开放-封闭原则" class="headerlink" title="20、开放-封闭原则"></a>20、开放-封闭原则</h3><h4 id="20-1-扩展window-onload函数"><a href="#20-1-扩展window-onload函数" class="headerlink" title="20.1 扩展window.onload函数"></a>20.1 扩展<code>window.onload</code>函数</h4><h4 id="20-2-开放和封闭"><a href="#20-2-开放和封闭" class="headerlink" title="20.2 开放和封闭"></a>20.2 开放和封闭</h4><h4 id="20-3-用对象的多态性消除条件分支"><a href="#20-3-用对象的多态性消除条件分支" class="headerlink" title="20.3 用对象的多态性消除条件分支"></a>20.3 用对象的多态性消除条件分支</h4><h4 id="20-4-找出变化的地方"><a href="#20-4-找出变化的地方" class="headerlink" title="20.4 找出变化的地方"></a>20.4 找出变化的地方</h4><h4 id="20-5-设计模式中的开放-封闭原则"><a href="#20-5-设计模式中的开放-封闭原则" class="headerlink" title="20.5 设计模式中的开放-封闭原则"></a>20.5 设计模式中的开放-封闭原则</h4><h4 id="20-6-开放-封闭原则的相对性"><a href="#20-6-开放-封闭原则的相对性" class="headerlink" title="20.6 开放-封闭原则的相对性"></a>20.6 开放-封闭原则的相对性</h4><h4 id="20-7-接受第一次愚弄"><a href="#20-7-接受第一次愚弄" class="headerlink" title="20.7 接受第一次愚弄"></a>20.7 接受第一次愚弄</h4><h3 id="21、接口和面向接口编程"><a href="#21、接口和面向接口编程" class="headerlink" title="21、接口和面向接口编程"></a>21、接口和面向接口编程</h3><h4 id="21-1-回到Java的抽象类"><a href="#21-1-回到Java的抽象类" class="headerlink" title="21.1 回到Java的抽象类"></a>21.1 回到Java的抽象类</h4><h4 id="21-2-interface"><a href="#21-2-interface" class="headerlink" title="21.2 interface"></a>21.2 interface</h4><h4 id="21-3-JavaScript语言是否需要抽象类和interface"><a href="#21-3-JavaScript语言是否需要抽象类和interface" class="headerlink" title="21.3 JavaScript语言是否需要抽象类和interface"></a>21.3 JavaScript语言是否需要抽象类和interface</h4><h4 id="21-4-用鸭子类型进行接口检查"><a href="#21-4-用鸭子类型进行接口检查" class="headerlink" title="21.4 用鸭子类型进行接口检查"></a>21.4 用鸭子类型进行接口检查</h4><h4 id="21-5-用TypeScript编写基于interface的命令模式"><a href="#21-5-用TypeScript编写基于interface的命令模式" class="headerlink" title="21.5 用TypeScript编写基于interface的命令模式"></a>21.5 用TypeScript编写基于interface的命令模式</h4><h3 id="22、代码重构"><a href="#22、代码重构" class="headerlink" title="22、代码重构"></a>22、代码重构</h3><h4 id="22-1-提炼函数"><a href="#22-1-提炼函数" class="headerlink" title="22.1 提炼函数"></a>22.1 提炼函数</h4><h4 id="22-2-合并重复的条件片段"><a href="#22-2-合并重复的条件片段" class="headerlink" title="22.2 合并重复的条件片段"></a>22.2 合并重复的条件片段</h4><h4 id="22-3-把条件分支语句提炼成函数"><a href="#22-3-把条件分支语句提炼成函数" class="headerlink" title="22.3 把条件分支语句提炼成函数"></a>22.3 把条件分支语句提炼成函数</h4><h4 id="22-4-合理使用循环"><a href="#22-4-合理使用循环" class="headerlink" title="22.4 合理使用循环"></a>22.4 合理使用循环</h4><h4 id="22-5-提前让函数退出代替嵌套条件分支"><a href="#22-5-提前让函数退出代替嵌套条件分支" class="headerlink" title="22.5 提前让函数退出代替嵌套条件分支"></a>22.5 提前让函数退出代替嵌套条件分支</h4><h4 id="22-6-传递对象参数代替过长的参数列表"><a href="#22-6-传递对象参数代替过长的参数列表" class="headerlink" title="22.6 传递对象参数代替过长的参数列表"></a>22.6 传递对象参数代替过长的参数列表</h4><h4 id="22-7-尽量减少参数数量"><a href="#22-7-尽量减少参数数量" class="headerlink" title="22.7 尽量减少参数数量"></a>22.7 尽量减少参数数量</h4><h4 id="22-8-少用三目运算符"><a href="#22-8-少用三目运算符" class="headerlink" title="22.8 少用三目运算符"></a>22.8 少用三目运算符</h4><h4 id="22-9-合理使用链式调用"><a href="#22-9-合理使用链式调用" class="headerlink" title="22.9 合理使用链式调用"></a>22.9 合理使用链式调用</h4><h4 id="22-10-分解大类型"><a href="#22-10-分解大类型" class="headerlink" title="22.10 分解大类型"></a>22.10 分解大类型</h4><h4 id="22-11-用return退出多重循环"><a href="#22-11-用return退出多重循环" class="headerlink" title="22.11 用return退出多重循环"></a>22.11 用return退出多重循环</h4>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6标准入门</title>
      <link href="/posts/es6.html"/>
      <url>/posts/es6.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Node</title>
      <link href="/posts/Node.html"/>
      <url>/posts/Node.html</url>
      
        <content type="html"><![CDATA[<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Node已经是一门非常成熟而且非常火热的技术了，作为一个前端菜鸟，我觉得有必要把读书笔记写出来。我见过有些人学一门技术，从一开始就只专注于技术本身，不去了解该技术产生的历史背景和契机，个人感觉这样并不是很妥，所以就先从Node的历史来学起，加油！        </p><h2 id="第1章-Node简介"><a href="#第1章-Node简介" class="headerlink" title="第1章 Node简介"></a>第1章 Node简介</h2><h3 id="1-1-Node的诞生历程"><a href="#1-1-Node的诞生历程" class="headerlink" title="1.1 Node的诞生历程"></a>1.1 Node的诞生历程</h3><p>2009年3月，Ryan Dahl（赖恩·代赫勒）宣布要创建一个基于V8的轻量级的Web服务器饼提供了一套库。<br>2009年5月，作者已经在GitHub上放出了最初的版本。（老外的效率就是高……🤔）<br>2009年和2010年，连续两届JSConf大会都安排了Node的讲座。<br>接下来从2010年年底开始，Node就迎来了它的“黄金时期”，在GitHub上坐上了“万年老二”的位置，2011年发布了支持windows系统的Node版本。</p><h3 id="1-2-Node的命名与起源"><a href="#1-2-Node的命名与起源" class="headerlink" title="1.2 Node的命名与起源"></a>1.2 Node的命名与起源</h3><h4 id="1-2-1-为什么是JavaScript"><a href="#1-2-1-为什么是JavaScript" class="headerlink" title="1.2.1 为什么是JavaScript"></a>1.2.1 为什么是JavaScript</h4><p>为什么作者偏偏选中了JavaScript呢？通俗的来讲，就是作者遇到挫折了，他想要的高性能web服务器需要满足两个要点：事件驱动以及非阻塞I&#x2F;O，纵观当时的开发语言，符合这两点的只有JavaScript，所以作者就选了JavaScript作为Node的实现语言。（老外还真就是喜欢折腾，不过我喜欢😍）</p><h4 id="1-2-2-为什么叫Node"><a href="#1-2-2-为什么叫Node" class="headerlink" title="1.2.2 为什么叫Node"></a>1.2.2 为什么叫Node</h4><p>至于Node的命名也是五花八门，但是都离不开Node和js，因为Node就是基于浏览器的V8引擎实现对脚本的处理的，所以叫Nodejs，Node.js等等这类名字完全和它的作用和起源相符，但是最后的正式称谓还是Node。</p><p>作者在最初的时候，并没有想用这个名字，而是用了web.js给他的项目命名，但是后来发现，项目的发展超过了他当时只想开发一个web服务器的想法，反而变成了构建网络应用的一个基础框框，那咋办，那就把目标调高一点，干脆做一个构建快速、可伸缩的网络应用平台吧，这个平台通过通信协议来组织许多Node，然后就像连点成线、连线成面一样，通过扩展来达成构建大型网络应用，不得不说，真NB。每一个Node进程都是这个网络应用中的一个节点，so，就干脆叫这名儿吧，朴实无华还贴切。</p><h3 id="1-3-Node给JavaScript带来的意义"><a href="#1-3-Node给JavaScript带来的意义" class="headerlink" title="1.3 Node给JavaScript带来的意义"></a>1.3 Node给JavaScript带来的意义</h3><p>如果说V8给Chrome浏览器带来的是一颗强大的心脏，那么Node对于JavaScript的意义就是把其从Chrome浏览器中解放出来，给了JavaScript更大的舞台。众所周知的是，Chrome浏览器拥有两个引擎，一个呢就是我们熟知的JavaScript引擎（V8），还有一个就是WebKit布局引擎，WebKit用来处理布局样式，而V8则用来处理脚本，在实现上，浏览器提供了越来越多的功能暴露给JavaScript和HTML标签，但是就前端浏览器的发展现状而言，HTML5标准统一的过程是相对缓慢的，就好比一个智商180的天才和一个智商100的普通人在同一所学校读书，普通人还在读三年级，但是天才已经读完了高三，这样天才肯定得去读大学了，不然就会限制他的发展，用俗话说就是“我们这小庙容不下您这大佛”，所以Node的作者就把Chrome的V8独立出来，然后基于V8写出了Node，他给了Node更多的扩展，就像给JavaScript插上翅膀一样，可以让它放飞自我。</p><p>Node和Chrome的结构十分相似，他们都是基于<strong>事件驱动</strong>和<strong>异步架构</strong>，浏览器通过<strong>事件驱动</strong>来服务<strong>页面上的交互</strong>，Node通过<strong>事件驱动</strong>来服务<strong>I&#x2F;O</strong>。</p><p>在Node中，JavaScript可以更加随心所欲的干着访问本地服务器、连接数据库、搭建web服务器等等，终于不再局限与和CSS以及DOM树打交道。如果说<strong>HTTP协议栈</strong>是水平面，那么Node就是浏览器在协议另一边的倒影。Node不用处理UI，但用与浏览器相同的<strong>机制</strong>和<strong>原理</strong>运行。正是因为Node打破了JavaScript只能在浏览器中运行的局面，所以才使得前后端开发环境可以统一，大大降低了前后端转换需要的上下文交换代价。</p><p>近几年随着前端工程师的兴起，Node也随之大放异彩。甚至目前在社区上已经出现了node-webkit这样的项目，顾名思义，在这样的项目中，将Node中的<strong>事件循环</strong>和WebKit中的<strong>事件循环</strong>融合在一起，说白了就是，既可以享受HTML、CSS带来的UI构建，也能通过它访问本地资源，将两者的优势更好地融合在了一起。到目前为止，桌面应用程序（Desktop Application）的开发可以完全通过HTML、CSS、JavaScript来完成。（结尾还是得扣666…😂）</p><h3 id="1-4-Node的特点"><a href="#1-4-Node的特点" class="headerlink" title="1.4 Node的特点"></a>1.4 Node的特点</h3><h4 id="1-4-1-异步I-x2F-O"><a href="#1-4-1-异步I-x2F-O" class="headerlink" title="1.4.1 异步I&#x2F;O"></a>1.4.1 异步I&#x2F;O</h4><p>说到异步，前端工程师首先肯定会想到Ajax（[ˈeɪdʒæks]），没错，Ajax就是一个异步的一个典型，比如：</p><pre class=" language-javascript"><code class="language-javascript">$<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"/url"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>title <span class="token punctuation">:</span> <span class="token string">'小白的Node之路'</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"收到响应"</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"发送Ajax结束"</span><span class="token punctuation">)</span></code></pre><p>如上述代码，熟悉异步的朋友一定知道，“收到响应”是在“发送Ajax结束”之后输出的，因为在调用<code>$.post()</code>后，后续的代码是立即执行的，而“收到响应”的时间是不固定的，我们只知道“收到响应”是在“发送Ajax结束”之后执行，但是并不知道“收到响应”的具体时间，这和<strong>异步调用</strong>中对于结果的捕获规则是相符的，具体是什么规则呢，简言之就是，你女朋友在忙的时候会告诉你，我忙完了会联系你，你不用给我打电话，这就是规则。（(⊙o⊙)…女人应该就是这样子的😂）</p><p>再附上一张经典的Ajax调用图以供大家参考：<br><img src="/../assets/ajax.jpg" alt="经典的Ajax调用"> </p><p>在Node中，异步I&#x2F;O也是随处可见的，就拿简单的读取文件为例，它和Ajax的调用方式是极其类似的：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">"/path"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"读取文件完成"</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"发起读取文件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>同样，在上述代码中的“读取文件完成”是在“发起读取文件”之后输出的，“读取文件完成”也取决于读取文件的异步调用何时结束。<br>结尾再附上一张经典的异步调用图：<br><img src="/../assets/asynchronous.jpg" alt="经典的异步调用"> </p><p>在Node中，绝大部分操作都是以异步的方式进行的，因为这样的话每个调用都无需等待之前的I&#x2F;O调用结束，这样可以在编程模型上极大的提升效率，比如下面的代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">"/path1"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"读取文件1完成"</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">"/path2"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"读取文件2完成"</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上述代码中，两个文件读取任务的耗时取决于最慢的那个文件读取的耗时，而对于同步I&#x2F;O而言，它们的耗时是两个任务的耗时之和，所以在这里能很明显地感受到异步带来的优势，确实是提高了效率。</p><h4 id="1-4-2-事件与回调函数"><a href="#1-4-2-事件与回调函数" class="headerlink" title="1.4.2 事件与回调函数"></a>1.4.2 事件与回调函数</h4><p>随着Web2.0时代的到来，JavaScript在前端中已经成了主宰一般的存在，随之而来的事件也得到了广泛的应用。</p><p>事件的编程方式具有<code>轻量级</code>、<code>松耦合</code>、<code>只关注事务点</code>等优势，但是在多个异步任务的场景下，事件与事件之间项目独立，如何协作就成了一个老大难问题。<br>先看下面的代码，第一段代码是Node创建一个Web服务器，并监听8080端口：</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">var</span> queryString <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"queryString"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 侦听服务器的request事件</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> postData <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 侦听请求的data事件</span>    req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        postData <span class="token operator">+</span><span class="token operator">=</span> chunk<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 侦听请求的end事件</span>    req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>postData<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"服务器启动完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第二段代码是为Ajax绑定了success事件，只关心请求成功时的业务逻辑：</p><pre class=" language-javascript"><code class="language-javascript">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token string">'url'</span><span class="token punctuation">:</span> <span class="token string">"/url"</span><span class="token punctuation">,</span>    <span class="token string">'method'</span><span class="token punctuation">:</span> <span class="token string">"POOST"</span><span class="token punctuation">,</span>    <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token string">'success'</span><span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// success事件</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span></code></pre><p>从上边的代码可以看出，回调函数是无处不在的。这是因为在JavaScript中，回调函数是一等公民，可以将函数作为对象传递给方法作为实参进行调用。不过回调函数使得很多习惯了同步思路的开发人员很头疼，使用起来也不是那么顺手，因为在他们的思想里程序一定是自上而下执行的，但是回调函数的出现使得代码的编写顺序与执行顺序没有了关系，所以WTF😒。</p><h4 id="1-4-3-单线程"><a href="#1-4-3-单线程" class="headerlink" title="1.4.3 单线程"></a>1.4.3 单线程</h4><p>Node保持了JavaScript在浏览器中单线程的特点，而且在Node中，JavaScript与其余线程是无法共享任何状态的。<br>单线程最大的好处就是不用像多线程编程那样时时刻刻要在意状态同步的问题，没有锁死的存在，也没有上下文交换所带来的性能上的开销。而单线程的缺点主要有以下三方面：</p><ul><li>无法利用多核CPU</li><li>错误会引起整个应用退出，应用的健壮性值得考验（说白了就是断了一条腿就把命丢了🤔）</li><li>大量计算占用CPU导致无法继续调用异步I&#x2F;O（CPU：我TM在忙，等会儿……😒）<br>在浏览器中，JavaScript与UI是公用一个线程的，如果JavaScript长时间执行会导致UI的渲染和响应被中断。在Node中也是一样的，长时间的CPU占用会导致后续的异步I&#x2F;O发不出调用，已完成的异步I&#x2F;O的回调函数也会得不到及时执行。为了解决这个问题，Google研发了Gears，它会启用一个独立的进程去执行需要计算的程序，然后把结果通过事件的方式传回，这样很大程度上降低了阻塞的几率。后来，HTML5发明了Web Workers，逃不过的真香定律，Google放弃Gears来支持Web Workers。再后来，Node也使用了和Web Workers相同的思路来解决这个问题，这就是<code>child_process</code>（子进程）。<br>子进程的出现，使得Node可以从容的应对单线程在健壮性和无法利用多核CPU方面的问题。<br>Node在进程管理方面采用的就是<code>Master-Worker</code>的管理方式，<code>Master-Worker</code>模式的核心思想是在于Master进程和Worker进程各自分担各自的任务,协同完成信息处理的模式，如下图就很清楚地说明了该管理方式：<br><img src="/../assets/masterWorker.png" alt="Master-Worker"> <h4 id="1-4-4-跨平台"><a href="#1-4-4-跨平台" class="headerlink" title="1.4.4 跨平台"></a>1.4.4 跨平台</h4>在Node发明之处，只能运行在Linux系统中（这不坑爹么😒），但是随着Node的发展，微软爸爸感觉这家伙越来越强大，就干脆找了一帮人实现了Node对Windows的兼容（666😂），微软发明的这玩意儿叫<code>libuv</code>，至于这玩意儿是啥，后期会讲到（呃，是学到😅），现在只要记住它是操作系统与Node上层模块系统之家构建的一层<code>平台层架构</code>就可以了，不过<code>libuv</code>也属实NB，现在已经成为了许多系统实现跨平台的基础组件了。（这就不能用666来形容了，应该是999，6翻了……😂）<h3 id="1-5-Node的应用场景"><a href="#1-5-Node的应用场景" class="headerlink" title="1.5 Node的应用场景"></a>1.5 Node的应用场景</h3><h4 id="1-5-1-I-x2F-O密集型（I-x2F-O-bound）"><a href="#1-5-1-I-x2F-O密集型（I-x2F-O-bound）" class="headerlink" title="1.5.1 I&#x2F;O密集型（I&#x2F;O bound）"></a>1.5.1 I&#x2F;O密集型（I&#x2F;O bound）</h4><code>I/O密集型</code>指的是<code>系统的CPU性能</code> <code>相对硬盘、内存</code>要好很多，此时，系统运作，大部分的状况是CPU在等I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，此时CPU Loading并不高。<br>从单线程的角度来说，Node处理I&#x2F;O的能力是一流的。Node面向网络且擅长并行I&#x2F;O，能够有效地组织起更多的硬件资源，从而提供更好的服务。<br><code>I/O密集</code>的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用较少。<h4 id="1-5-2-是否不擅长CPU密集型业务"><a href="#1-5-2-是否不擅长CPU密集型业务" class="headerlink" title="1.5.2 是否不擅长CPU密集型业务"></a>1.5.2 是否不擅长CPU密集型业务</h4>Node虽然在I&#x2F;O密集型场景中大放异彩，但是在CPU密集型中也能胜任，这得益于V8的深度性能优化。<br>先说说什么是<code>CPU密集型（CPU-bound）</code>？</li></ul><ul><li>CPU密集型也叫计算密集型，指的是<code>系统的硬盘、内存性能</code> <code>相对CPU</code>要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读&#x2F;写I&#x2F;O(硬盘&#x2F;内存)，I&#x2F;O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。</li><li>在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</li><li>CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I&#x2F;O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I&#x2F;O的时间。</li></ul><p>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I&#x2F;O无法发起。<br>Node应对上述挑战的方法是：适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞调用的发起，这样既可同时享受到并行异步I&#x2F;O的好处，又能充分利用CPU。所以说，CPU密集不可怕，如何合理调度是诀窍。</p><h4 id="1-5-3-与遗留系统和平共处"><a href="#1-5-3-与遗留系统和平共处" class="headerlink" title="1.5.3 与遗留系统和平共处"></a>1.5.3 与遗留系统和平共处</h4><p>Node还有一个好处就是，在一些老旧的项目中，比如JSP&#x2F;ASP，前后端不分离，这样对一些没有Java开发经验的前端工程师来讲是一件比较头疼的事，但Node的出现，既使得前端工程师在HTTP协议栈的两端能够高效灵活的开发，避免了Java繁琐的表达，又可以利用Java作为后端接口和中间件，使其具有良好的稳定性，两者可以相互结合，取长补短。</p><h4 id="1-5-4-分布式应用"><a href="#1-5-4-分布式应用" class="headerlink" title="1.5.4 分布式应用"></a>1.5.4 分布式应用</h4><p>说到<code>分布式应用</code>，百度百科给出的释义是：分布式应用（distributed application）指的是应用程序分布在不同计算机上，通过网络来共同完成一项任务的工作方式。<br>分布式应用的典型案例莫过于阿里巴巴的数据平台。众所周知，阿里的数据量是非常巨大的，所有存储数据的一定是用数据库集群来存储的，这样对于查询数据也是一个考验，因此，阿里团队研发除了中间层应用（NodeFox、ITier），简单来说就是，查询调用依旧是针对单张表进行SQL查询，中间层分解查询SQL，然后并行地去多台数据库中获取数据然后合并。</p><p>举个简单的例子，就好比你急着结婚，但是没对象，没办法只能相亲，然后你把你的要求告诉了身边的亲戚朋友甚至是媒人（这就是中间层），让他们根据你提的条件去找合适的相亲对象，找到以后反馈给你。（相亲是一条不归路，且相且珍惜😑……）</p><h3 id="1-6-Node的使用者"><a href="#1-6-Node的使用者" class="headerlink" title="1.6 Node的使用者"></a>1.6 Node的使用者</h3><p>就目前Node对于前端工程师的意义来说，一些中小企业的前端工程师是用Node来做中间层和一些工具的开发，能真正使用Node来做开发的公司是较少的，就拿本人来讲，学Node仅仅是为了在面试的时候多一个加分项，虽然肤浅，但是快乐😅。</p><h2 id="第2章-模块机制"><a href="#第2章-模块机制" class="headerlink" title="第2章 模块机制"></a>第2章 模块机制</h2><h3 id="2-1-CommonJS规范"><a href="#2-1-CommonJS规范" class="headerlink" title="2.1 CommonJS规范"></a>2.1 CommonJS规范</h3><h4 id="2-1-1-CommonJS的出发点"><a href="#2-1-1-CommonJS的出发点" class="headerlink" title="2.1.1 CommonJS的出发点"></a>2.1.1 CommonJS的出发点</h4><p>要谈CommonJS的出发点，那就得先了解一下是什么原因促成了它的出现，是爱吗？是责任吗？都不是，是因为JavaScript规范的以下缺陷：</p><ul><li><strong>没有模块系统。</strong></li><li><strong>标准库较少。</strong>ECMAScript仅定义了部分核心库，对于文件系统，I&#x2F;O流等常见的需求却没有标准的API。就HTML5的发展状况而言，W3C标准化在一定意义上是在推进这个过程，但他仅限于浏览器端。</li><li><strong>没有标准接口。</strong>在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口。</li><li><strong>缺乏包管理系统。</strong>这导致JavaScript中基本没有自动加载和安装依赖的能力。<br>由于上述缺陷，JavaScript只能停留在小脚本程序的阶段，但是，俗话说，不想当厨子的老师不是好警察，咳咳，JavaScript当然也不会偏安一隅，而CommonJS规范的提出，就是为了弥补上述缺陷，从而使JavaScript达到具备开发大型应用且应用可以跨宿主环境执行的目的，比如做一些服务端JavaScript应用程序、命令行工具、桌面图形界面应用程序、混合应用等等。现如今，CommonJS规范已经涵盖了模块、二进制、Buffer、字符集编码、I&#x2F;O流、进程环境、文件系统、套接字、Web服务器网关接口、包管理等。<h4 id="2-1-2-CommonJS的模块规范"><a href="#2-1-2-CommonJS的模块规范" class="headerlink" title="2.1.2 CommonJS的模块规范"></a>2.1.2 CommonJS的模块规范</h4>CommonJS对模块的定义十分简单，主要分为<code>模块引用</code>、<code>模块定义</code>和<code>模块标识</code>三个部分。</li></ul><p><strong>1、模块引用</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'math'</span><span class="token punctuation">)</span></code></pre><p><strong>2、模块定义</strong><br>在模块中，上下文提供<code>require()</code>方法来引入外部模块。对应引入的功能，上下文提供了<code>exports对象</code>用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个<code>module对象</code>，它代表模块本身，而<code>exports</code>是<code>module</code>的属性。在Node中，一个文件就是一个模块，将方法挂载在<code>exports对象</code>上作为属性即可定义导出的方式：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// math.js</span>exports<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  args <span class="token operator">=</span> arguments<span class="token punctuation">,</span>  l <span class="token operator">=</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    sum <span class="token operator">+</span><span class="token operator">=</span> args<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> </code></pre><p>在另一个文件中，我们通过<code>require()</code>方法引入模块后，就能调用定义的属性或方法了：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// program.js</span><span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'math'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>exports<span class="token punctuation">.</span>increment <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>3、模块标识</strong><br>模块标识其实就是传递给<code>require()</code>方法的参数，它必须是符合<code>小驼峰</code>命名的字符串，或者以<code>·</code>、<code>··</code>开头的相对路径，或者绝对路径。它可以没有文件后缀名<code>.js</code>。<br>模块的定义十分简单，接口也十分简洁。它的意义在于将类聚的<code>方法</code>和<code>变量</code>等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。<br>CommonJS构建的这套模块导出和引入机制使得用户完全不必要考虑变量污染，命名空间等方案与之相比相形见绌。</p><h3 id="2-2-Node的模块实现"><a href="#2-2-Node的模块实现" class="headerlink" title="2.2 Node的模块实现"></a>2.2 Node的模块实现</h3><p>Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了少许自身的特性。在Node中引入模块，需要经历如下三个步骤：</p><ul><li>1、路径分析</li><li>2、文件定位</li><li>3、编译执行<br>在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用于编写的模块，称为文件模块。</li></ul><ul><li><strong>核心模块：</strong>核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块还引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。（打娘胎带出来的就是不一样，这都有特权😒）</li><li><strong>文件模块：</strong>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。（你的出身就决定了你的一生……🙃）<h4 id="2-2-1-优先从缓存加载"><a href="#2-2-1-优先从缓存加载" class="headerlink" title="2.2.1 优先从缓存加载"></a>2.2.1 优先从缓存加载</h4>与前端浏览器会缓存静态脚本一样，Node也会对引入过的模块进行缓存，以减少二次引入的开销。两者的不同在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。<br>不论是核心模块还是文件模块，<code>require()</code>方法对相同的模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。（落在平阳的虎它毕竟还是虎，落在架上的凤凰它终究还是凤凰……😏）<h4 id="2-2-2-路径分析和文件定位"><a href="#2-2-2-路径分析和文件定位" class="headerlink" title="2.2.2 路径分析和文件定位"></a>2.2.2 路径分析和文件定位</h4>因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异。<h5 id="1、模块标识符分析"><a href="#1、模块标识符分析" class="headerlink" title="1、模块标识符分析"></a>1、模块标识符分析</h5>在Node中，模块标识符主要分为以下几类：</li></ul><ul><li>核心模块，如http、fs、path等。</li><li><code>.</code>或<code>..</code>开始的相对路径文件模块。</li><li>以<code>/</code>开始的绝对路径文件模块。</li><li>非路径形式的文件模块，如自定义的connect模块。</li></ul><p><strong>①核心模块</strong><br>核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。<br>如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。<br><strong>②路径形式的文件模块</strong><br>一<code>.</code>、<code>..</code>和<code>/</code>开始的标识符，这里都被当作文件模块来处理。在分析文件模块时，<code>require()</code>方法会将路径转为真是路径，并以真实路径作为索引，将编译执行后的结果放在缓存中，以使二次加载时更快。<br>由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。<br><strong>③自定义模块</strong><br>自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方法中最慢的一种。<br><code>模块路径</code>是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。如下所示：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span> <span class="token string">'/Users/shenchenhao/Desktop/test/node_modules'</span><span class="token punctuation">,</span>  <span class="token string">'/Users/shenchenhao/Desktop/node_modules'</span><span class="token punctuation">,</span>  <span class="token string">'/Users/shenchenhao/node_modules'</span><span class="token punctuation">,</span>  <span class="token string">'/Users/node_modules'</span><span class="token punctuation">,</span>  <span class="token string">'/node_modules'</span> <span class="token punctuation">]</span></code></pre><p>模块路径的生成规则如下所示：</p><ul><li>当前文件下的node_modules目录。</li><li>父目录下的node_modules目录。</li><li>父目录的父目录下的node_modules目录。</li><li>沿路径向上逐级递归，直到根目录下的node_modules目录。<br>当文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。<h5 id="2、文件定位"><a href="#2、文件定位" class="headerlink" title="2、文件定位"></a>2、文件定位</h5>从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。</li></ul><p><strong>①文件扩展名分析</strong><br><code>require()</code>在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按<code>.js</code>、<code>.json</code>、<code>.node</code>的次序补足扩展名，依次尝试。<br>在尝试过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍：如果是<code>.node</code>和<code>.json</code>文件，在传递给<code>require()</code>的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。<br><strong>②目录分析和包</strong><br>在分析标识符的过程中，<code>require()</code>通过分析文件扩展名之后，可能没有查到对应文件夹，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将此目录当做一个包来处理。<br>在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过<code>JSON.parse()</code>解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。<br>而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当作默认文件名，然后依次查找index.js、index.json、index.node。<br>如果再目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完，依然没有查找到目标文件，则会抛出查找失败的异常。</p><h4 id="2-2-3-模块编译"><a href="#2-2-3-模块编译" class="headerlink" title="2.2.3 模块编译"></a>2.2.3 模块编译</h4><p>在Node中，每个文件模块都是一个对象，它的定义如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Module</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>filename <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同。具体如下所示：<br>**<code>.js文件</code>**通过fs模块同步读取文件后编译执行。<br>**<code>.node文件</code><strong>这是用C&#x2F;C++编写的扩展文件，通过</strong>dlopen()**方法加载最后编译生成的文件。<br>**<code>.json文件</code><strong>通过fs模块同步读取文件后，用</strong>JSON.parse()**解析返回结果。<br><strong><code>其余扩展名文件</code><strong>它们都被当做</strong>.js</strong>文件载入。<br>每一个编译成功的模块都会将其文件路径作为索引缓存在<code>Module._cathe</code>对象上，以提高二次引入的性能。在确定文件的扩展名之后，Node将调用具体的编译方式来将文件执行后返回给调用者。<br><strong>①JavaScript模块的编译</strong><br>回到CommonJS规范，我们知道每个模块文件中存在着<code>require</code>、<code>exports</code>、<code>module</code>这3个变量，但是它们在模块文件中并没有定义，那么从何而来呢？甚至在Node的API文档中，我们知道每个模块中还有<code>__filename</code>、<code>__dirname</code>这两个变量的存在，它们又是从何而来呢？如果我们把直接定义模块的过程放在浏览器端，会存在污染全局变量的情况。<br>事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, __filename, __dirname) {\n, 在尾部添加了\n})；。一个正常的JavaScript文件会被包装成如下样子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> module<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'math'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    exports<span class="token punctuation">.</span>area <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>radius<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> radius <span class="token operator">*</span> radius<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span></code></pre><p>这样在每个模块文件之间都进行了作用域隔离。包装之后的代码会通过<code>vm</code>原生模块的<code>runInThisContext()</code>方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的function对象。最后，将当前模块对象的exports属性、require()方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。<br>这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。<br>至此，require、exports、module的流程已经完整，这就是Node对CommonJS模块规范的实现。<br><strong>②C&#x2F;C++模块的编译</strong><br>Node调用<code>process.dlopen()</code>方法进行加载和执行。在Node的框架下，dlopen()方法在Windows和Unix平台下分别有不同的实现，通过libuv兼容层进行了封装。<br>实际上，<code>.node</code>的模块文件不需要编译，因为它是编写C&#x2F;C++模块之后编译生成的，所以这里只有加载和执行的过程。在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。<br>C&#x2F;C++模块给Node使用者带来的优势主要是执行效率方面的，劣势则是C&#x2F;C++模块的编写门槛比JavaScript高。<br><strong>③JSON文件的编译</strong><br><code>.json</code>文件的编译是3种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用。<br>JSON文件在用在项目的配置文件时比较有用。如果已经定义了一个JSON文件作为配置，那就不必调用fs模块去异步读取和解析，直接调用require()引入即可。此外，还可以享受到模块缓存的便利，并且二次引入时也没有性能影响。</p><h3 id="2-3-核心模块"><a href="#2-3-核心模块" class="headerlink" title="2.3 核心模块"></a>2.3 核心模块</h3><p>Node的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块其实分为C&#x2F;C++编写的和JavaScript编写的两部分，其中C&#x2F;C++文件存放在Node项目的src目录下，JavaScript文件存放在lib目录下。</p><h4 id="2-3-1-JavaScript的核心模块编译过程"><a href="#2-3-1-JavaScript的核心模块编译过程" class="headerlink" title="2.3.1 JavaScript的核心模块编译过程"></a>2.3.1 JavaScript的核心模块编译过程</h4><p>在编译所有C&#x2F;C++文件之前，编译程序需要将所有的JavaScript模块文件编译为C&#x2F;C++代码，此时不是直接将其编译为可执行代码。<br><strong>①转存为C&#x2F;C++代码</strong><br>Node采用了<code>V8</code>附带的<code>js2c.py</code>工具，将所有内置的JavaScript代码（src&#x2F;node.js和lib&#x2F;*.js）转换成C&#x2F;C++里的数组，生成<code>node_natives.h</code>头文件，相关代码如下：</p><pre class=" language-c"><code class="language-c">namespace node <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> node_native<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> dgram_native<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> console_native<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> buffer_native<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> querystring<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> punycode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    struct_native <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> source<span class="token punctuation">;</span>        size_t source_len<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> struct_native natives<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">"node"</span><span class="token punctuation">,</span> node_native<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>node_native<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">"dgram"</span><span class="token punctuation">,</span> dgram_native<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dgram_native<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>在这个过程中，JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。<br><strong>②编译JavaScript核心模块</strong><br><code>lib</code>目录下的所有模块文件也没有定义require、module、exports这些变量。在引入JavaScript核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置。<br>JavaScript核心模块的定义如下面的代码所示，源文件通过<code>process.binding(&#39;natives&#39;)</code>取出，编译成功的模块缓存到<code>NativeModule._cache</code>对象上，文件模块则缓存到<code>Module._cache</code>对象上：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> NativeModule <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>filename <span class="token operator">=</span> id <span class="token operator">+</span> <span class="token string">'.js'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> NativeModule<span class="token punctuation">.</span>_source <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">binding</span><span class="token punctuation">(</span><span class="token string">'natives'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>NativeModule<span class="token punctuation">.</span>_cache <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><h4 id="2-3-2-C-x2F-C-核心模块的编译过程"><a href="#2-3-2-C-x2F-C-核心模块的编译过程" class="headerlink" title="2.3.2 C&#x2F;C++核心模块的编译过程"></a>2.3.2 C&#x2F;C++核心模块的编译过程</h4><p>在核心模块中，有些模块全部由C&#x2F;C++编写，有些模块则由C&#x2F;C++完成核心部分，其他部分则由JavaScript实现包装或向外导出，以满足性能需求，这种模式是Node能够提高性能的常见方式。通常，脚本语言的开发速度优于静态语言，但是其性能却弱于静态语言。而Node的这种复合模式可以在开发速度和性能之间找到平衡点。<br>这里我们将那些由纯C&#x2F;C++编写的部分统一称为内建模块，因为它们通常不被用户直接调用。Node的buffer、crypto、evals、fs等模块都是部分通过C&#x2F;C++编写的。<br><strong>①内建模块的组织形式</strong><br>在Node中，内建模块的内部结构定义如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> node_module_struct<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> version<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>dso_handle<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>register_func<span class="token punctuation">)</span> <span class="token punctuation">(</span>v8<span class="token punctuation">:</span><span class="token punctuation">:</span>Handle<span class="token operator">&lt;</span>v8<span class="token punctuation">:</span><span class="token punctuation">:</span>Object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>modname<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>每一个内建模块在定义之后，都通过<code>NODE_MODULE</code>宏模块将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的<code>register_func</code>成员：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> NODE_MODULE(modname, regfunc)</span><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    NODE_MODULE_EXPORT node<span class="token punctuation">:</span><span class="token punctuation">:</span>node_module_struct modname ## _module <span class="token operator">=</span>     <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        MODE_STANDARD_MODULE_STUFF<span class="token punctuation">,</span>        regfunc<span class="token punctuation">,</span>        <span class="token function">MODE_STRINGIFY</span><span class="token punctuation">(</span>modname<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><code>node_extentions.h</code>文件将这些散列的内建模块统一放进了一个叫<code>node_module_list</code>的数组中，这些模块有：</p><ul><li>node_buffer</li><li>node_crypto</li><li>node_evals</li><li>node_fs</li><li>node_http_parser</li><li>node_os</li><li>node_zlib</li><li>node_timer_wrap</li><li>node_tcp_wrap</li><li>node_udp_wrap</li><li>node_pipe_wrap</li><li>node_cares_wrap</li><li>node_tty_wrap</li><li>node_process_wrap</li><li>node_fs_event_wrap</li><li>node_signal_watcher<br>取出这些内建模块的方法也很简单，Node提供了<code>get_builtin_module()</code>方法从node_module_list数组中取出这些模块。<br>内建模块的优势在于：首先，它们本身由C&#x2F;C++编写，性能上优于脚本语言；其次，在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接就可执行。</li></ul><p><strong>②内建模块的导出</strong><br>在Node的所有模块类型中，存在着一种层级依赖关系，即：文件模块可能会依赖核心模块，核心模块可能会依赖内建模块。<br>通常，不推荐文件模块直接调用内建模块，如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块。Node在启动时，会生成一个全局变量process，并提供<code>Binding()</code>方法来协助加载内建模块。<br>在加载内建模块时，我们先创建一个<code>exports</code>空对象，然后用<code>get_bultin_module()</code>方法取出内建模块对象，通过执行<code>register_func()</code>填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成指导。<br>这个方法不仅可以导出内建方法，还能导出一些别的内容。比如JavaScript核心文件被转换为C&#x2F;C++数组存储后，便是通过<code>process_binding(&#39;natives&#39;)</code>取出放置在<code>NativeModule._source</code>中的：<code>NativeModule._source = process_binding(&#39;natives&#39;)</code>；该方法将通过js2c.py工具转换出的字符串数组取出，然后重新转换为普通字符串，以对JavaScript核心模块进行编译和执行。</p><h4 id="2-3-3-核心模块的引入流程"><a href="#2-3-3-核心模块的引入流程" class="headerlink" title="2.3.3 核心模块的引入流程"></a>2.3.3 核心模块的引入流程</h4><p>为了符合CommonJS模块规范，从JavaScript到C&#x2F;C++的过程是相当复杂的，它要经历C&#x2F;C++层面的内建模块定义、（JavaScript）核心模块的定义和引入以及（JavaScript）文件模块层面的引入。但是对于用户而言，<code>require()</code>十分简洁、友好。下图是引入流程：<br><img src="/../assets/os.png" alt="os原生模块的引入流程"> </p><h4 id="2-3-4-编写核心模块"><a href="#2-3-4-编写核心模块" class="headerlink" title="2.3.4 编写核心模块"></a>2.3.4 编写核心模块</h4><p>核心模块被编译进二进制文件需要遵循一定规则。<br>核心模块中的JavaScript部分几乎与文件模块的开发相同，遵循CommonJS模块规范，上下文中除了拥有require、module、exports外，还可以调用Node中的一些全局变量。<br>下面我们以C&#x2F;C++模块为例演示如何编写内建模块。我们先编写一个极其简单的JavaScript版本的原型，这个方法返回一个Hello World字符串：</p><pre class=" language-javascript"><code class="language-javascript">exports<span class="token punctuation">.</span>sayHello <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>编写内建模块通常分为两步：编写头文件和编写C&#x2F;C++文件。<br><strong>1、将以下代码保存为<code>node_hello.h</code>，存放到Node的src目录下：</strong></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> NODE_HELLO_H_</span><span class="token macro property">#<span class="token directive keyword">define</span> NODE_HELLO_H_</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;v8.h></span></span>namespace node <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 预定义方法</span>    v8<span class="token punctuation">:</span>Handle<span class="token operator">&lt;</span>v8<span class="token punctuation">:</span><span class="token punctuation">:</span>value<span class="token operator">></span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token keyword">const</span> v8<span class="token punctuation">:</span><span class="token punctuation">:</span>Arguments <span class="token operator">&amp;</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>2、编写<code>node_hello.cc</code>，并保存到src目录下：</strong></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;node.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;node_hello.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;v8.h></span></span>namespace node <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    using namespace v8<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实现预定义的方法</span>    Handle<span class="token operator">&lt;</span>Value<span class="token operator">></span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token keyword">const</span> Arguments<span class="token operator">&amp;</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        HandleScope scope<span class="token punctuation">;</span>        <span class="token keyword">return</span> scope<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 给传入的目标对象添加SayHello方法</span>    <span class="token keyword">void</span> <span class="token function">Init_Hello</span><span class="token punctuation">(</span>Handle<span class="token operator">&lt;</span>Object<span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        target<span class="token operator">-></span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">NewSymbol</span><span class="token punctuation">(</span><span class="token string">"SayHello"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>FunctionTemplete<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">New</span><span class="token punctuation">(</span>SayHello<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用NODE_MODULE()将注册方法定义到内存中</span><span class="token function">NODE_MODULE</span><span class="token punctuation">(</span>node_hellp<span class="token punctuation">,</span>node<span class="token punctuation">:</span><span class="token punctuation">:</span>Init_Hello<span class="token punctuation">)</span></code></pre><p>以上两步完成了内建模块的编写，但是要真正的让Node认为它是内建模块，还需要更改<code>src/node_extentions.h</code>，在<code>NODE_EXT_LIST_END</code>前添加<code>NODE_EXT_LIST_ITEM(node_hello)</code>，以将node_hello模块添加进node_module_list数组中。<br>其次，还需要让编写的两份代码编译进执行文件，同时需要更改Node的 项目生成文件node.gup，并在’target_name’:’node’节点的source中添加上新编写的两个文件，然后编译整个Node项目。</p><h3 id="2-4-C-x2F-C-扩展模块"><a href="#2-4-C-x2F-C-扩展模块" class="headerlink" title="2.4 C&#x2F;C++扩展模块"></a>2.4 C&#x2F;C++扩展模块</h3><h4 id="2-4-1-前提条件"><a href="#2-4-1-前提条件" class="headerlink" title="2.4.1 前提条件"></a>2.4.1 前提条件</h4><p><strong>①GYP项目生成工具。</strong>该工具可以跨平台使用，Node自身的源码就是通过GYP编译的。<br><strong>②V8引擎C++库。</strong>V8是Node自身的动力来源之一。它自身由C++写成，可以实现JavaScript与C++的互相调用。<br><strong>③libuv库。</strong>它是Node自身的动力来源之二。Node能够实现跨平台的一个诀窍就是它的libuv库，这个库是跨平台的一层封装，通过它去调用一些底层操作，比自己再各个平台下编写实现要高效得多。libuv封装的功能包括事件循环、文件操作等。<br><strong>④Node内部库。</strong>写C++模块时，免不了要做一些面向对象的编程工作，而Node自身提供了一些C++代码，比如node::ObjectWrap类可以用来包装你的自定义类，它可以帮助实现对象回收等工作。<br><strong>⑤其他库。</strong>如zlib、openssl、http_parser等。</p><h4 id="2-4-2-C-x2F-C-扩展模块的编写"><a href="#2-4-2-C-x2F-C-扩展模块的编写" class="headerlink" title="2.4.2 C&#x2F;C++扩展模块的编写"></a>2.4.2 C&#x2F;C++扩展模块的编写</h4><p>普通的扩展模块与内建模块的区别在于无须将源代码编译进Node，而是通过dlopen()方法动态加载。所以在编写普通的扩展模块时，无须将源代码写进node命名空间。<br>C++扩展模块与内建模块的套路一样，将方法挂载在target对象上，然后通过NODE_MODULE生命即可。<br>由于不像编写内建模块那样将对象声明到node_module_list链表中，所以无法被认作是一个原生模块，只能通过dlopen()来动态加载，然后导出给JavaScript调用。</p><h4 id="2-4-3-C-x2F-C-扩展模块的编译"><a href="#2-4-3-C-x2F-C-扩展模块的编译" class="headerlink" title="2.4.3 C&#x2F;C++扩展模块的编译"></a>2.4.3 C&#x2F;C++扩展模块的编译</h4><p>在GYP工具的帮助下，编译C++模块无须为每个平台编写不同的项目编译文件，只需要写好<code>.gyp</code>项目文件就可以了。（有关于C++的部分我是真的不会，只能略过，卒😞）</p><h4 id="2-4-4-C-x2F-C-扩展模块的加载"><a href="#2-4-4-C-x2F-C-扩展模块的加载" class="headerlink" title="2.4.4 C&#x2F;C++扩展模块的加载"></a>2.4.4 C&#x2F;C++扩展模块的加载</h4><p>用一张图说明吧：<br><img src="/../assets/node_core_module_import.jpeg" alt="require()引入.node文件的过程"> </p><h3 id="2-5-模块调用栈"><a href="#2-5-模块调用栈" class="headerlink" title="2.5 模块调用栈"></a>2.5 模块调用栈</h3><p>C&#x2F;C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。<br>JavaScript核心模块主要扮演的职责有两类：一类是作为C&#x2F;C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。<br>文件模块通常由第三方编写，包括普通JavaScript模块和C&#x2F;C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块。<br>模块之间的调用关系如下图所示：<br><img src="/../assets/diaoyong.png" alt="模块之间的调用关系"> </p><h3 id="2-6-包与NPM"><a href="#2-6-包与NPM" class="headerlink" title="2.6 包与NPM"></a>2.6 包与NPM</h3><p>Node组织了自身的核心模块，也使得第三方文件模块可以有序地编写和使用。但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用。而在模块之外，包和NPM则是将模块联系起来的一种机制。<br>JavaScript不像Java或者其他语言那样，具有模块和包结构。Node对模块规范的实现，一定程度上解决了变量依赖、依赖关系等代码组织性问题。包的出现，则是在模块的基础上进一步组织JavaScript代码。如图为包组织模块示意图：<br><img src="/../assets/npm.png" alt="包组织模块示意图"><br>CommonJS的包规范的定义也十分简单，它由<code>包结构</code>和<code>包描述文件</code>两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。</p><h4 id="2-6-1-包结构"><a href="#2-6-1-包结构" class="headerlink" title="2.6.1 包结构"></a>2.6.1 包结构</h4><p>包实际上是一个存档文件，即一个目录直接打包为<code>.zip</code>或<code>tar.gz</code>格式的文件，安装后解压还原为目录。完全符合CommonJS规范的包目录应该包含如下文件：</p><ul><li>package.json：包描述文件</li><li>bin：用于存放可执行二进制文件的目录</li><li>lib：用于存放JavaScript代码的目录</li><li>doc：用于存放文档的目录</li><li>test：用于存放单元测试用例的代码<br>可以看到，CommonJS包规范从文档、测试等方面都做过考虑。当一个包完成向外公布时，用户看到单元测试和文档的时候，会给他们一种踏实可靠的感觉。<h4 id="2-6-2-包描述文件与NPM"><a href="#2-6-2-包描述文件与NPM" class="headerlink" title="2.6.2 包描述文件与NPM"></a>2.6.2 包描述文件与NPM</h4>包描述文件用于表达非代码相关的信息，它是一个<code>JSON</code>格式的文件————<code>package.json</code>，位于包的根目录下，是包的重要组成部分。而NPM的所有行为都与包描述文件的字段息息相关。<br>CommonJS为<code>package.json</code>文件定义了如下一些必需的字段：</li><li>name。包名。规范定义它需要由小写的字母和数字组成，可以包含<code>. 、 _</code>和<code>-</code>,但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或js来重复标识它是JavaScript或Node模块。</li><li>description。包简介。</li><li>version。 版本号。一个语义化的版本号，该版本号十分重要，常常用于一些版本控制的场合。</li><li>keywords。关键字数组，NPM中主要用来做分类搜索，便于用户快速找到你的包。</li><li>maintainers。包维护者列表。每个维护者由name、email和web这三个属性组成。NPM通过该属性进行权限认证。</li><li>contributors。贡献者列表。格式与维护者列表相同。</li><li>bugs。一个可以反馈bug的网页地址或邮件地址。</li><li>license。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。</li><li>repositories。托管源代码的位置列表，表示可以通过哪些方式和地址访问包的源代码。</li><li>dependencies。使用当前包所需要依赖的包列表。NPM会通过这个属性帮助自动加载依赖的包。<br>除了必选字段外，规范还定义了一部分可选字段：</li><li>homepage。当前包的网站地址。</li><li>os。操作系统支持列表。如果设置了列表为空，则不对操作系统做任何假设。</li><li>cpu。CPU架构的支持列表，同os一样，如果列表为空，则不对CPU架构做任何假设。</li><li>engine。支持的JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node和v8。</li><li>builtin。标志当前包是否是内建在底层系统的标准组件。</li><li>directories。包目录说明。</li><li>implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范。</li><li>scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。<br>包规范的定义可以帮助Node解决依赖包安装的问题，而NPM正是基于该规范进行了实现。<br>在包描述文件的规范中，与包规范的区别在于多了以下字段：</li><li>author。包作者。</li><li>bin。一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过<code>npm install package_name -g</code>命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。</li><li>main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其他模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json作为默认入口。</li><li>devDependencies。一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包。<h4 id="2-6-3-NPM常用功能"><a href="#2-6-3-NPM常用功能" class="headerlink" title="2.6.3 NPM常用功能"></a>2.6.3 NPM常用功能</h4></li></ul><h4 id="2-6-4-局域NPM"><a href="#2-6-4-局域NPM" class="headerlink" title="2.6.4 局域NPM"></a>2.6.4 局域NPM</h4><h4 id="2-6-5-NPM潜在问题"><a href="#2-6-5-NPM潜在问题" class="headerlink" title="2.6.5 NPM潜在问题"></a>2.6.5 NPM潜在问题</h4><h3 id="2-7-前后端公用模块"><a href="#2-7-前后端公用模块" class="headerlink" title="2.7 前后端公用模块"></a>2.7 前后端公用模块</h3><h4 id="2-7-1-模块的侧重点"><a href="#2-7-1-模块的侧重点" class="headerlink" title="2.7.1 模块的侧重点"></a>2.7.1 模块的侧重点</h4><h4 id="2-7-2-AMD规范"><a href="#2-7-2-AMD规范" class="headerlink" title="2.7.2 AMD规范"></a>2.7.2 AMD规范</h4><h4 id="2-7-3-CMD规范"><a href="#2-7-3-CMD规范" class="headerlink" title="2.7.3 CMD规范"></a>2.7.3 CMD规范</h4><h4 id="2-7-4兼容多种规范模式"><a href="#2-7-4兼容多种规范模式" class="headerlink" title="2.7.4兼容多种规范模式"></a>2.7.4兼容多种规范模式</h4><h2 id="第3章-异步I-x2F-O"><a href="#第3章-异步I-x2F-O" class="headerlink" title="第3章 异步I&#x2F;O"></a>第3章 异步I&#x2F;O</h2><h2 id="第4章-异步编程"><a href="#第4章-异步编程" class="headerlink" title="第4章 异步编程"></a>第4章 异步编程</h2><h2 id="第5章-内存控制"><a href="#第5章-内存控制" class="headerlink" title="第5章 内存控制"></a>第5章 内存控制</h2><h2 id="第6章-理解Buffer"><a href="#第6章-理解Buffer" class="headerlink" title="第6章 理解Buffer"></a>第6章 理解Buffer</h2><h2 id="第7章-网络编程"><a href="#第7章-网络编程" class="headerlink" title="第7章 网络编程"></a>第7章 网络编程</h2><h2 id="第8章-构建Web应用"><a href="#第8章-构建Web应用" class="headerlink" title="第8章 构建Web应用"></a>第8章 构建Web应用</h2><h2 id="第9章-玩转进程"><a href="#第9章-玩转进程" class="headerlink" title="第9章 玩转进程"></a>第9章 玩转进程</h2><h2 id="第10章-测试"><a href="#第10章-测试" class="headerlink" title="第10章 测试"></a>第10章 测试</h2><h2 id="第11章-产品化"><a href="#第11章-产品化" class="headerlink" title="第11章 产品化"></a>第11章 产品化</h2>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript5.1</title>
      <link href="/posts/ES5.html"/>
      <url>/posts/ES5.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、ES5简介"><a href="#一、ES5简介" class="headerlink" title="一、ES5简介"></a>一、ES5简介</h2><p>ES5是ECMAScript标准最新修正。与H5规范进程本质类似，ES5通过对现有JavaScript方法添加语句和原生ECNAScript对象做合并实现标准化。ES5还引入了一个语法的严格变种，被称为“严格模式（strict mode）”。</p><h2 id="二、浏览器支持"><a href="#二、浏览器支持" class="headerlink" title="二、浏览器支持"></a>二、浏览器支持</h2><ul><li>Opera 11.60</li><li>IE9+ （IE9不支持严格模式）</li><li>Firefox 4</li><li>Safari 5.1+</li><li>Chrome 13</li></ul><p><strong>如果想在低版本浏览器中支持严格模式，需要下载shim</strong></p><h2 id="三、ES5的严格模式"><a href="#三、ES5的严格模式" class="headerlink" title="三、ES5的严格模式"></a>三、ES5的严格模式</h2><p>严格模式给作者提供了选择一个限制性更强语言变种的方式–给作者提供额外的可靠性给用户提供额外的安全性。在JS文件或者函数的顶部添加”use strict”即可启用严格模式。因为”use strict”是一个字符串，所以会被旧版浏览器忽略。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">MSDN中的严格模式介绍</a></p><h2 id="四、JSON格式"><a href="#四、JSON格式" class="headerlink" title="四、JSON格式"></a>四、JSON格式</h2><p>ES5提供一个全局的<strong>JSON</strong>对象，用来序列化(JSON.stringfy)和反序列化(JSON.parse)对象为JSON格式。<br>对于老的浏览器，可以考虑使用Dougulas Crockford的<strong>json2.js</strong>，可以让旧的浏览器实现同样的功能（原始支持功能测试后）。</p><p><strong>JSON.parse(text [, reviever])<strong>接受文本(JSON格式)并转换成一个ECMAScript值。该方法可选的参数是有带有</strong>key</strong>和<strong>value</strong>两个参数的函数，作用是过滤和转换返回值。<br>例如：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">var</span> result <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">"a"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">==</span> <span class="token string">"string"</span><span class="token punctuation">)</span>            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> value<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>JSON.stringfy(value [, replacer [, space]])<strong>允许作者接受一个ECMAScript值然后转化成JSON格式的字符串。在最简单的形式中，</strong>JSON.stringfy</strong>接受一个值返回一个字符串。<br>例如：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">var</span> zs <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>age<span class="token punctuation">:</span><span class="token string">"aaa"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token keyword">typeof</span> zs    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// string</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>zs<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// &amp;#123;"age":"18"&amp;#125;</span></code></pre><p>如果我们需要改变字符串化的方式，或是对我们选择的提供过滤，我们可以将其传给<strong>replacer</strong>函数。<br>例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> nums <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token string">"first"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">"second"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token string">"third"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> res <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> undefined<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//&amp;#123;"first":1,"second":2&amp;#125;</span></code></pre><p>如果<strong>replacer</strong>函数返回<strong>undefined</strong>，则键值对就不会包含在最终的JSON中。我们同样可以传递一个<strong>space</strong>参数以便获得返回结果的可读性帮助。<strong>space</strong>参数可以是个数字，表明缩进的空格数。如果参数是个超过10的数值，或是超过10个字符的字符串，将导致取10或是截取前10个字符。<br>例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> nums <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token string">"first"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">"second"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token string">"third"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> res <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> undefined<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/** &amp;#123;  "first": 1,  "second": 2&amp;#125;**/</span></code></pre><h2 id="五、附加对象"><a href="#五、附加对象" class="headerlink" title="五、附加对象"></a>五、附加对象</h2><p>以下方法是添加到<strong>Object</strong>上的构造器：</p><ul><li><code>Object.assign()</code> 通过复制一个或多个对象来创建一个新的对象。</li><li><code>Object.create()</code> 使用指定的原型对象和属性创建一个新对象。</li><li><code>Object.defineProperty()</code> 给对象添加一个属性并指定该属性的配置。</li><li><code>Object.defineProperties()</code> 给对象添加多个属性并分别指定它们的配置。</li><li><code>Object.entries()</code> 返回给定对象自身可枚举属性的 [key, value] 数组。</li><li><code>Object.freeze()</code> 冻结对象：其他代码不能删除或更改任何属性。</li><li><code>Object.getOwnPropertyDescriptor()</code> 返回对象指定的属性配置。</li><li><code>Object.getOwnPropertyNames()</code> 返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。</li><li><code>Object.getOwnPropertySymbols()</code> 返回一个数组，它包含了指定对象自身所有的符号属性。</li><li><code>Object.getPrototypeOf()</code>返回指定对象的原型对象。</li><li><code>Object.is()</code> 比较两个值是否相同。所有 NaN 值都相等（这与&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;不同）。</li><li><code>Object.isExtensible()</code> 判断对象是否可扩展。</li><li><code>Object.isFrozen()</code> 判断对象是否已经冻结。</li><li><code>Object.isSealed()</code> 判断对象是否已经密封。</li><li><code>Object.keys()</code> 返回一个包含所有给定对象自身可枚举属性名称的数组。</li><li><code>Object.preventExtensions()</code> 防止对象的任何扩展。</li><li><code>Object.seal()</code> 防止其他代码删除对象的属性。</li><li><code>Object.setPrototypeOf()</code> 设置对象的原型（即内部 [[Prototype]] 属性）。</li><li><code>Object.values()</code> 返回给定对象自身可枚举值的数组。</li></ul><p>具体参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">Object构造函数的方法</a></p><h2 id="六、额外的数组"><a href="#六、额外的数组" class="headerlink" title="六、额外的数组"></a>六、额外的数组</h2><p>具体参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">Array的方法</a></p><h2 id="七、Function-prototype-bind-thisArg-arg1-arg2-…"><a href="#七、Function-prototype-bind-thisArg-arg1-arg2-…" class="headerlink" title="七、Function.prototype.bind(thisArg[,arg1[,arg2[, …]]])"></a>七、Function.prototype.bind(thisArg[,arg1[,arg2[, …]]])</h2><p><code>Function.prototype.bind()</code>返回一个新的函数对象，在<code>bind()</code>被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。<br>具体使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">Function.prototype.bind()详解</a></p><h2 id="八、This指针的使用"><a href="#八、This指针的使用" class="headerlink" title="八、This指针的使用"></a>八、This指针的使用</h2><p>通俗来讲，就是谁调用<code>this</code>，<code>this</code>就指向谁。<br>例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 1、常规的this指向</span><span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    m <span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>    test<span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>m<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行test的时候，this被obj调用，所以this指向obj</span><span class="token comment" spellcheck="true">// 2、闭包中的this指向</span><span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    m <span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>    test<span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>m<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>m<span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 100 1000</span>构造函数中的<span class="token keyword">this</span>主动权比较大。</code></pre><h2 id="九、变量的作用域和闭包"><a href="#九、变量的作用域和闭包" class="headerlink" title="九、变量的作用域和闭包"></a>九、变量的作用域和闭包</h2><p>js是函数级作用域，在内部的变量，内部都能访问，外部不能访问内部的变量，内部能访问外部的变量。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript教程</title>
      <link href="/posts/TypeScript.html"/>
      <url>/posts/TypeScript.html</url>
      
        <content type="html"><![CDATA[<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最近团队中开始使用React+TypeScript来重构前端项目了，和同事聊了一下，感觉自己的TS知识还是有很多欠缺，今天就开始系统的梳理一下吧！</p><h2 id="一、Typescript入门【上】"><a href="#一、Typescript入门【上】" class="headerlink" title="一、Typescript入门【上】"></a>一、Typescript入门【上】</h2><h3 id="1-1-Typescript介绍"><a href="#1-1-Typescript介绍" class="headerlink" title="1.1 Typescript介绍"></a>1.1 Typescript介绍</h3><ul><li>Typescript简介：<ul><li>Typescript是微软开发的JavaScript的超集，Typescript兼容JavaScript，可以载入JavaScript代码然后运行。</li></ul></li><li>Typescript与JavaScript比较：<ul><li>Typescript与JavaScript相比进步的地方包括：<br>  ① 加入注释，让编译器理解所支持的对象和函数，编译器会移除注释，不会增加开销<br>  ② 增加一个完整的类结构，使之更新是传统的面向对象语言</li></ul></li><li>语法特性：<ul><li>类 <code>Classes</code></li><li>接口 <code>Interfaces</code></li><li>模块 <code>Modules</code></li></ul></li></ul><h3 id="1-2-Typescript环境搭建——MacOS-X-环境搭建"><a href="#1-2-Typescript环境搭建——MacOS-X-环境搭建" class="headerlink" title="1.2 Typescript环境搭建——MacOS X 环境搭建"></a>1.2 Typescript环境搭建——MacOS X 环境搭建</h3><ul><li>集成开发环境：<ul><li>WebStorm</li><li>VScode</li></ul></li><li>安装TypeScript：<ul><li>homebrew：<br>  MacOS下的套件管理器，安装命令<code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code></li><li>npm：<br>  npm的全称是Node Package Manager，是Nodejs的包管理器，安装命令<code>brew install node</code></li><li>TypeScript：<br>  安装命令<code>npm install -g typescript</code></li></ul></li></ul><h3 id="1-3-Typescript环境搭建——Windows环境搭建"><a href="#1-3-Typescript环境搭建——Windows环境搭建" class="headerlink" title="1.3 Typescript环境搭建——Windows环境搭建"></a>1.3 Typescript环境搭建——Windows环境搭建</h3><ul><li>集成开发环境：<ul><li>WebStorm</li><li>VScode</li></ul></li><li>安装TypeScript：<ul><li>nodejs：<br>  直接去nodejs官网去下载安装包安装即可</li><li>TypeScript：<br>  安装命令<code>npm install -g typescript</code></li></ul></li></ul><h3 id="2-1-基本数据类型——boolean、number、string"><a href="#2-1-基本数据类型——boolean、number、string" class="headerlink" title="2.1 基本数据类型——boolean、number、string"></a>2.1 基本数据类型——boolean、number、string</h3><ul><li>Boolean<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">let</span> isDone<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span></code></pre></li><li>Number<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">let</span> decLiteral<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> hexLiteral<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">0xf00d</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> binaryLiteral<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">0b1010</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> octalLiteral<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">0o744</span><span class="token punctuation">;</span></code></pre></li><li>String<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">=</span> <span class="token string">"bob"</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">=</span> <span class="token string">'Alice'</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Gene`</span></span><span class="token punctuation">;</span>    name <span class="token operator">=</span> <span class="token string">"smith"</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="2-2-基本数据结构——Array、Tuple、enum"><a href="#2-2-基本数据结构——Array、Tuple、enum" class="headerlink" title="2.2 基本数据结构——Array、Tuple、enum"></a>2.2 基本数据结构——Array、Tuple、enum</h3><ul><li>Array<br>  TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 <ul><li><p>第一种，可以在元素类型后面接上<code>[]</code>，表示由此类型元素组成的一个数组：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> list<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></li><li><p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：<br>  &#96;&#96;&#96;typescript<br>  let list: Array<number> &#x3D; [1, 2, 3];</p><p>  let list: Array<string> &#x3D; [“张三”, “李四”, “王五”];</p></li></ul><p>  &#96;&#96;&#96;</p></li><li>Tuple<br>  元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。<pre class=" language-typescript"><code class="language-typescript">    <span class="token comment" spellcheck="true">// 声明一个元组类型</span>    <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确初始化这个元组</span>    x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误的初始化（原因：类型不匹配）</span>    x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </code></pre>  当访问一个已知索引的元素，会得到正确的类型：<pre class=" language-typescript"><code class="language-typescript">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误, 'number' does not have 'substr'，数字类型没有substr方法</span></code></pre>  当访问一个越界的元素，会使用联合类型替代：<pre class=" language-typescript"><code class="language-typescript">    x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'world'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK, 字符串可以赋值给(string | number)类型</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK, 'string' 和 'number' 都有 toString</span>    x<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error, 布尔不是(string | number)类型</span></code></pre></li><li>enum<br>  <code>enum</code>类型是对<code>JavaScript</code>标准数据类型的一个补充。 像<code>C#</code>等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">enum</span> Color <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> c<span class="token punctuation">:</span> Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span></code></pre>  默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">enum</span> Color <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>Red <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> c<span class="token punctuation">:</span> Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span></code></pre>  或者，全部都采用手动赋值：<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">enum</span> Color <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>Red <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> Green <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> Blue <span class="token operator">=</span> <span class="token number">4</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> c<span class="token punctuation">:</span> Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span></code></pre>  枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">enum</span> Color <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>Red <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> colorName<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">=</span> Color<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>colorName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 显示'Green'因为上面代码里它的值是2</span></code></pre></li></ul><h3 id="2-3-基本数据类型——Any、Void、Object"><a href="#2-3-基本数据类型——Any、Void、Object" class="headerlink" title="2.3 基本数据类型——Any、Void、Object"></a>2.3 基本数据类型——Any、Void、Object</h3><ul><li>Any<br>  有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用<code>any</code>类型来标记这些变量：<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">let</span> notSure<span class="token punctuation">:</span> <span class="token keyword">any</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    notSure <span class="token operator">=</span> <span class="token string">"maybe a string instead"</span><span class="token punctuation">;</span>    notSure <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// okay, definitely a boolean</span></code></pre>  在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为<code>Object</code>有相似的作用，就像它在其它语言中那样。 但是<code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">let</span> notSure<span class="token punctuation">:</span> <span class="token keyword">any</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    notSure<span class="token punctuation">.</span><span class="token function">ifItExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// okay, ifItExists might exist at runtime</span>    notSure<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// okay, toFixed exists (but the compiler doesn't check)</span>    <span class="token keyword">let</span> prettySure<span class="token punctuation">:</span> Object <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    prettySure<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: Property 'toFixed' doesn't exist on type 'Object'.</span></code></pre>  当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">let</span> list<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token string">"free"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></code></pre></li><li>Void<br>  某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是<code>void</code>：<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">function</span> <span class="token function">warnUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"This is my warning message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>  声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">let</span> unusable<span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token operator">=</span> undefined<span class="token punctuation">;</span></code></pre></li><li>Object<br>  <code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。<br>  使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的<code>API</code>。例如：<pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">:</span> object <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>    <span class="token function">create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> prop<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK</span>    <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK</span>    <span class="token function">create</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error</span>    <span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error</span>    <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error</span>    <span class="token function">create</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error</span></code></pre></li></ul><h3 id="3-1-TS函数——函数类型"><a href="#3-1-TS函数——函数类型" class="headerlink" title="3.1 TS函数——函数类型"></a>3.1 TS函数——函数类型</h3><ul><li><p>函数<br>  和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。</p><p>  通过下面的例子可以迅速回想起这两种JavaScript中的函数：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// Named function</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Anonymous function</span><span class="token keyword">let</span> myAdd <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>  在JavaScript里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助。</p><pre class=" language-typescript"><code class="language-typescript">    <span class="token keyword">let</span> z <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">addToZ</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>函数类型</p><ul><li><p>为函数定义类型<br>  让我们为上面那个函数添加类型：<br>  &#96;&#96;&#96;typescript<br>  function add(x: number, y: number): number {<br>  return x + y;<br>  }</p><p>  let myAdd &#x3D; function(x: number, y: number): number { return x + y; };</p></li></ul><pre><code>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。- 书写完整函数类型现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。```typescript    let myAdd: (x: number, y: number) =&gt; number =    function(x: number, y: number): number &#123; return x + y; &#125;;</code></pre><p>  函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写：</p><pre class=" language-typescript"><code class="language-typescript">   <span class="token keyword">let</span> myAdd<span class="token punctuation">:</span> <span class="token punctuation">(</span>baseValue<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> increment<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">number</span> <span class="token operator">=</span>   <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>  只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p><p>  第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用<code>( =&gt;)</code>符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为<code>void</code>而不能留空。</p><p>  函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。</p><ul><li><p>推断类型<br>  尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型：<br>  &#96;&#96;&#96;typescript<br> &#x2F;&#x2F; myAdd has the full function type<br> let myAdd &#x3D; function(x: number, y: number): number { return x + y; };</p><p> &#x2F;&#x2F; The parameters <code>x</code> and <code>y</code> have the type number<br> let myAdd: (baseValue: number, increment: number) &#x3D;&gt; number &#x3D;<br> function(x, y) { return x + y; };</p></li></ul><p>  &#96;&#96;&#96;<br>  这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。</p></li></ul><h3 id="3-2-TS函数——可选和默认参数"><a href="#3-2-TS函数——可选和默认参数" class="headerlink" title="3.2 TS函数——可选和默认参数"></a>3.2 TS函数——可选和默认参数</h3><ul><li>可选参数和默认参数<br>  <code>TypeScript</code>里的每个函数参数都是必须的。 这不是指不能传递<code>null</code>或<code>undefined</code>作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。<pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span>firstName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> lastName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error, too few parameters</span><span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Adams"</span><span class="token punctuation">,</span> <span class="token string">"Sr."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error, too many parameters</span><span class="token keyword">let</span> result3 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Adams"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ah, just right</span></code></pre></li></ul><h3 id="3-3-TS函数——可变参数"><a href="#3-3-TS函数——可变参数" class="headerlink" title="3.3 TS函数——可变参数"></a>3.3 TS函数——可变参数</h3><h2 id="二、Typescript入门【中】"><a href="#二、Typescript入门【中】" class="headerlink" title="二、Typescript入门【中】"></a>二、Typescript入门【中】</h2><h3 id="3-4-TS函数——Lambda和this关键字"><a href="#3-4-TS函数——Lambda和this关键字" class="headerlink" title="3.4 TS函数——Lambda和this关键字"></a>3.4 TS函数——Lambda和this关键字</h3><h3 id="3-5-TS函数——重载"><a href="#3-5-TS函数——重载" class="headerlink" title="3.5 TS函数——重载"></a>3.5 TS函数——重载</h3><h2 id="三、Typescript入门【下】"><a href="#三、Typescript入门【下】" class="headerlink" title="三、Typescript入门【下】"></a>三、Typescript入门【下】</h2><h2 id="四、Typescript入门【终】"><a href="#四、Typescript入门【终】" class="headerlink" title="四、Typescript入门【终】"></a>四、Typescript入门【终】</h2>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack从入门到精通</title>
      <link href="/posts/2874d81a.html"/>
      <url>/posts/2874d81a.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue源码解读</title>
      <link href="/posts/b2ef42f4.html"/>
      <url>/posts/b2ef42f4.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue从入门到精通</title>
      <link href="/posts/vue.html"/>
      <url>/posts/vue.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac中SVN的使用</title>
      <link href="/posts/use-svn-in-Mac.html"/>
      <url>/posts/use-svn-in-Mac.html</url>
      
        <content type="html"><![CDATA[<p>在 Windows 环境中，我们一般使用 TortoiseSVN 来搭建 svn 环境。在 Mac 环境下，由于 Mac 自带了 svn 的服务器端和客户端功能，所以我们可以在不装任何第三方软件的前提下使用 svn 功能，不过还需做一下简单的配置。</p><p>那么，如何在Mac环境下搭建svn服务器端环境呢</p><h4 id="创建代码仓库，用来存储客户端所上传的代码"><a href="#创建代码仓库，用来存储客户端所上传的代码" class="headerlink" title="创建代码仓库，用来存储客户端所上传的代码"></a>创建代码仓库，用来存储客户端所上传的代码</h4>]]></content>
      
      
      <categories>
          
          <category> SVN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> SVN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React从入门到入门</title>
      <link href="/posts/react.html"/>
      <url>/posts/react.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级程序设计1</title>
      <link href="/posts/JavaScript1.html"/>
      <url>/posts/JavaScript1.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-JavaScript简介"><a href="#第一章-JavaScript简介" class="headerlink" title="第一章 JavaScript简介"></a><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-JavaScript%E7%AE%80%E4%BB%8B" title="第一章 JavaScript简介"></a>第一章 JavaScript简介</h2><h3 id="1-1-JavaScript简史"><a href="#1-1-JavaScript简史" class="headerlink" title="1.1 JavaScript简史"></a><a href="#1-1-JavaScript%E7%AE%80%E5%8F%B2" title="1.1 JavaScript简史"></a>1.1 JavaScript简史</h3><h3 id="1-2-JavaScript实现"><a href="#1-2-JavaScript实现" class="headerlink" title="1.2 JavaScript实现"></a><a href="#1-2-JavaScript%E5%AE%9E%E7%8E%B0" title="1.2 JavaScript实现"></a>1.2 JavaScript实现</h3><h4 id="1-2-1-ECMAScript"><a href="#1-2-1-ECMAScript" class="headerlink" title="1.2.1 ECMAScript"></a><a href="#1-2-1-ECMAScript" title="1.2.1 ECMAScript"></a>1.2.1 ECMAScript</h4><h4 id="1-2-2-文档对象模型（DOM）"><a href="#1-2-2-文档对象模型（DOM）" class="headerlink" title="1.2.2 文档对象模型（DOM）"></a><a href="#1-2-2-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%88DOM%EF%BC%89" title="1.2.2 文档对象模型（DOM）"></a>1.2.2 文档对象模型（DOM）</h4><h4 id="1-2-3-浏览器对象模型（BOM）"><a href="#1-2-3-浏览器对象模型（BOM）" class="headerlink" title="1.2.3 浏览器对象模型（BOM）"></a><a href="#1-2-3-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%88BOM%EF%BC%89" title="1.2.3 浏览器对象模型（BOM）"></a>1.2.3 浏览器对象模型（BOM）</h4><h3 id="1-3-JavaScript版本"><a href="#1-3-JavaScript版本" class="headerlink" title="1.3 JavaScript版本"></a><a href="#1-3-JavaScript%E7%89%88%E6%9C%AC" title="1.3 JavaScript版本"></a>1.3 JavaScript版本</h3><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a><a href="#1-4-%E5%B0%8F%E7%BB%93" title="1.4 小结"></a>1.4 小结</h3><h2 id="第二章-在HTML中使用JavaScript"><a href="#第二章-在HTML中使用JavaScript" class="headerlink" title="第二章 在HTML中使用JavaScript"></a><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript" title="第二章 在HTML中使用JavaScript"></a>第二章 在HTML中使用JavaScript</h2><h3 id="2-1-script元素"><a href="#2-1-script元素" class="headerlink" title="2.1 script元素"></a><a href="#2-1-script%E5%85%83%E7%B4%A0" title="2.1 script元素"></a>2.1 script元素</h3><h4 id="2-1-1-标签的位置"><a href="#2-1-1-标签的位置" class="headerlink" title="2.1.1 标签的位置"></a><a href="#2-1-1-%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%8D%E7%BD%AE" title="2.1.1 标签的位置"></a>2.1.1 标签的位置</h4><h4 id="2-1-2-延迟脚本"><a href="#2-1-2-延迟脚本" class="headerlink" title="2.1.2 延迟脚本"></a><a href="#2-1-2-%E5%BB%B6%E8%BF%9F%E8%84%9A%E6%9C%AC" title="2.1.2 延迟脚本"></a>2.1.2 延迟脚本</h4><h4 id="2-1-3-异步脚本"><a href="#2-1-3-异步脚本" class="headerlink" title="2.1.3 异步脚本"></a><a href="#2-1-3-%E5%BC%82%E6%AD%A5%E8%84%9A%E6%9C%AC" title="2.1.3 异步脚本"></a>2.1.3 异步脚本</h4><h4 id="2-1-4-在XHTML中的语法"><a href="#2-1-4-在XHTML中的语法" class="headerlink" title="2.1.4 在XHTML中的语法"></a><a href="#2-1-4-%E5%9C%A8XHTML%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95" title="2.1.4 在XHTML中的语法"></a>2.1.4 在XHTML中的语法</h4><h4 id="2-1-5-不推荐使用的语法"><a href="#2-1-5-不推荐使用的语法" class="headerlink" title="2.1.5 不推荐使用的语法"></a><a href="#2-1-5-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95" title="2.1.5 不推荐使用的语法"></a>2.1.5 不推荐使用的语法</h4><h3 id="2-2-嵌入代码与外部文件"><a href="#2-2-嵌入代码与外部文件" class="headerlink" title="2.2 嵌入代码与外部文件"></a><a href="#2-2-%E5%B5%8C%E5%85%A5%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6" title="2.2 嵌入代码与外部文件"></a>2.2 嵌入代码与外部文件</h3><h3 id="2-3-文档模式"><a href="#2-3-文档模式" class="headerlink" title="2.3 文档模式"></a><a href="#2-3-%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F" title="2.3 文档模式"></a>2.3 文档模式</h3><h3 id="2-4-noscript元素"><a href="#2-4-noscript元素" class="headerlink" title="2.4 noscript元素"></a><a href="#2-4-noscript%E5%85%83%E7%B4%A0" title="2.4 noscript元素"></a>2.4 noscript元素</h3><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a><a href="#2-5-%E5%B0%8F%E7%BB%93" title="2.5 小结"></a>2.5 小结</h3><h2 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" title="第三章 基本概念"></a>第三章 基本概念</h2><h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a><a href="#3-1-%E8%AF%AD%E6%B3%95" title="3.1 语法"></a>3.1 语法</h3><h4 id="3-1-1-区分大小写"><a href="#3-1-1-区分大小写" class="headerlink" title="3.1.1 区分大小写"></a><a href="#3-1-1-%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99" title="3.1.1 区分大小写"></a>3.1.1 区分大小写</h4><h4 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2 标识符"></a><a href="#3-1-2-%E6%A0%87%E8%AF%86%E7%AC%A6" title="3.1.2 标识符"></a>3.1.2 标识符</h4><h4 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3 注释"></a><a href="#3-1-3-%E6%B3%A8%E9%87%8A" title="3.1.3 注释"></a>3.1.3 注释</h4><h4 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4 严格模式"></a><a href="#3-1-4-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F" title="3.1.4 严格模式"></a>3.1.4 严格模式</h4><h4 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5 语句"></a><a href="#3-1-5-%E8%AF%AD%E5%8F%A5" title="3.1.5 语句"></a>3.1.5 语句</h4><h3 id="3-2-关键字和保留字"><a href="#3-2-关键字和保留字" class="headerlink" title="3.2 关键字和保留字"></a><a href="#3-2-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97" title="3.2 关键字和保留字"></a>3.2 关键字和保留字</h3><h3 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a><a href="#3-3-%E5%8F%98%E9%87%8F" title="3.3 变量"></a>3.3 变量</h3><h3 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a><a href="#3-4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" title="3.4 数据类型"></a>3.4 数据类型</h3><h4 id="3-4-1-typeof操作符"><a href="#3-4-1-typeof操作符" class="headerlink" title="3.4.1 typeof操作符"></a><a href="#3-4-1-typeof%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.4.1 typeof操作符"></a>3.4.1 typeof操作符</h4><h4 id="3-4-2-Undefined类型"><a href="#3-4-2-Undefined类型" class="headerlink" title="3.4.2 Undefined类型"></a><a href="#3-4-2-Undefined%E7%B1%BB%E5%9E%8B" title="3.4.2 Undefined类型"></a>3.4.2 Undefined类型</h4><h4 id="3-4-3-Null类型"><a href="#3-4-3-Null类型" class="headerlink" title="3.4.3 Null类型"></a><a href="#3-4-3-Null%E7%B1%BB%E5%9E%8B" title="3.4.3 Null类型"></a>3.4.3 Null类型</h4><h4 id="3-4-4-Boolean类型"><a href="#3-4-4-Boolean类型" class="headerlink" title="3.4.4 Boolean类型"></a><a href="#3-4-4-Boolean%E7%B1%BB%E5%9E%8B" title="3.4.4 Boolean类型"></a>3.4.4 Boolean类型</h4><h4 id="3-4-5-Number类型"><a href="#3-4-5-Number类型" class="headerlink" title="3.4.5 Number类型"></a><a href="#3-4-5-Number%E7%B1%BB%E5%9E%8B" title="3.4.5 Number类型"></a>3.4.5 Number类型</h4><h4 id="3-4-6-String类型"><a href="#3-4-6-String类型" class="headerlink" title="3.4.6 String类型"></a><a href="#3-4-6-String%E7%B1%BB%E5%9E%8B" title="3.4.6 String类型"></a>3.4.6 String类型</h4><h4 id="3-4-7-Object类型"><a href="#3-4-7-Object类型" class="headerlink" title="3.4.7 Object类型"></a><a href="#3-4-7-Object%E7%B1%BB%E5%9E%8B" title="3.4.7 Object类型"></a>3.4.7 Object类型</h4><h3 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a><a href="#3-5-%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5 操作符"></a>3.5 操作符</h3><h4 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1 一元操作符"></a><a href="#3-5-1-%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.1 一元操作符"></a>3.5.1 一元操作符</h4><h4 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2 位操作符"></a><a href="#3-5-2-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.2 位操作符"></a>3.5.2 位操作符</h4><h4 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3 布尔操作符"></a><a href="#3-5-3-%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.3 布尔操作符"></a>3.5.3 布尔操作符</h4><h4 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4 乘性操作符"></a><a href="#3-5-4-%E4%B9%98%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.4 乘性操作符"></a>3.5.4 乘性操作符</h4><h4 id="3-5-5-加性操作符"><a href="#3-5-5-加性操作符" class="headerlink" title="3.5.5 加性操作符"></a><a href="#3-5-5-%E5%8A%A0%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.5 加性操作符"></a>3.5.5 加性操作符</h4><h4 id="3-5-6-关系操作符"><a href="#3-5-6-关系操作符" class="headerlink" title="3.5.6 关系操作符"></a><a href="#3-5-6-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.6 关系操作符"></a>3.5.6 关系操作符</h4><h4 id="3-5-7-相等操作符"><a href="#3-5-7-相等操作符" class="headerlink" title="3.5.7 相等操作符"></a><a href="#3-5-7-%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.7 相等操作符"></a>3.5.7 相等操作符</h4><h4 id="3-5-8-条件操作符"><a href="#3-5-8-条件操作符" class="headerlink" title="3.5.8 条件操作符"></a><a href="#3-5-8-%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.8 条件操作符"></a>3.5.8 条件操作符</h4><h4 id="3-5-9-赋值操作符"><a href="#3-5-9-赋值操作符" class="headerlink" title="3.5.9 赋值操作符"></a><a href="#3-5-9-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.9 赋值操作符"></a>3.5.9 赋值操作符</h4><h4 id="3-5-10-逗号操作符"><a href="#3-5-10-逗号操作符" class="headerlink" title="3.5.10 逗号操作符"></a><a href="#3-5-10-%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6" title="3.5.10 逗号操作符"></a>3.5.10 逗号操作符</h4><h3 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a><a href="#3-6-%E8%AF%AD%E5%8F%A5" title="3.6 语句"></a>3.6 语句</h3><h4 id="3-6-1-if语句"><a href="#3-6-1-if语句" class="headerlink" title="3.6.1 if语句"></a><a href="#3-6-1-if%E8%AF%AD%E5%8F%A5" title="3.6.1 if语句"></a>3.6.1 if语句</h4><h4 id="3-6-2-do-while语句"><a href="#3-6-2-do-while语句" class="headerlink" title="3.6.2 do-while语句"></a><a href="#3-6-2-do-while%E8%AF%AD%E5%8F%A5" title="3.6.2 do-while语句"></a>3.6.2 do-while语句</h4><h4 id="3-6-3-while语句"><a href="#3-6-3-while语句" class="headerlink" title="3.6.3 while语句"></a><a href="#3-6-3-while%E8%AF%AD%E5%8F%A5" title="3.6.3 while语句"></a>3.6.3 while语句</h4><h4 id="3-6-4-for语句"><a href="#3-6-4-for语句" class="headerlink" title="3.6.4 for语句"></a><a href="#3-6-4-for%E8%AF%AD%E5%8F%A5" title="3.6.4 for语句"></a>3.6.4 for语句</h4><h4 id="3-6-5-for-in语句"><a href="#3-6-5-for-in语句" class="headerlink" title="3.6.5 for-in语句"></a><a href="#3-6-5-for-in%E8%AF%AD%E5%8F%A5" title="3.6.5 for-in语句"></a>3.6.5 for-in语句</h4><h4 id="3-6-6-label语句"><a href="#3-6-6-label语句" class="headerlink" title="3.6.6 label语句"></a><a href="#3-6-6-label%E8%AF%AD%E5%8F%A5" title="3.6.6 label语句"></a>3.6.6 label语句</h4><h4 id="3-6-7-break和continue语句"><a href="#3-6-7-break和continue语句" class="headerlink" title="3.6.7 break和continue语句"></a><a href="#3-6-7-break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5" title="3.6.7 break和continue语句"></a>3.6.7 break和continue语句</h4><h4 id="3-6-8-with语句"><a href="#3-6-8-with语句" class="headerlink" title="3.6.8 with语句"></a><a href="#3-6-8-with%E8%AF%AD%E5%8F%A5" title="3.6.8 with语句"></a>3.6.8 with语句</h4><h4 id="3-6-9-switch语句"><a href="#3-6-9-switch语句" class="headerlink" title="3.6.9 switch语句"></a><a href="#3-6-9-switch%E8%AF%AD%E5%8F%A5" title="3.6.9 switch语句"></a>3.6.9 switch语句</h4><h3 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a><a href="#3-7-%E5%87%BD%E6%95%B0" title="3.7 函数"></a>3.7 函数</h3><h4 id="3-7-1-理解参数"><a href="#3-7-1-理解参数" class="headerlink" title="3.7.1 理解参数"></a><a href="#3-7-1-%E7%90%86%E8%A7%A3%E5%8F%82%E6%95%B0" title="3.7.1 理解参数"></a>3.7.1 理解参数</h4><h4 id="3-7-2-没有重载"><a href="#3-7-2-没有重载" class="headerlink" title="3.7.2 没有重载"></a><a href="#3-7-2-%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD" title="3.7.2 没有重载"></a>3.7.2 没有重载</h4><h3 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a><a href="#3-8-%E5%B0%8F%E7%BB%93" title="3.8 小结"></a>3.8 小结</h3><h2 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h2><h3 id="4-1-基本类型和引用类型的值"><a href="#4-1-基本类型和引用类型的值" class="headerlink" title="4.1 基本类型和引用类型的值"></a><a href="#4-1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC" title="4.1 基本类型和引用类型的值"></a>4.1 基本类型和引用类型的值</h3><h4 id="4-1-1-动态的属性"><a href="#4-1-1-动态的属性" class="headerlink" title="4.1.1 动态的属性"></a><a href="#4-1-1-%E5%8A%A8%E6%80%81%E7%9A%84%E5%B1%9E%E6%80%A7" title="4.1.1 动态的属性"></a>4.1.1 动态的属性</h4><h4 id="4-1-2-复制变量值"><a href="#4-1-2-复制变量值" class="headerlink" title="4.1.2 复制变量值"></a><a href="#4-1-2-%E5%A4%8D%E5%88%B6%E5%8F%98%E9%87%8F%E5%80%BC" title="4.1.2 复制变量值"></a>4.1.2 复制变量值</h4><h4 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3 传递参数"></a><a href="#4-1-3-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" title="4.1.3 传递参数"></a>4.1.3 传递参数</h4><h4 id="4-1-4-检测类型"><a href="#4-1-4-检测类型" class="headerlink" title="4.1.4 检测类型"></a><a href="#4-1-4-%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B" title="4.1.4 检测类型"></a>4.1.4 检测类型</h4><h3 id="4-2-执行环境及作用域"><a href="#4-2-执行环境及作用域" class="headerlink" title="4.2 执行环境及作用域"></a><a href="#4-2-%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F" title="4.2 执行环境及作用域"></a>4.2 执行环境及作用域</h3><h4 id="4-2-1-延长作用域链"><a href="#4-2-1-延长作用域链" class="headerlink" title="4.2.1 延长作用域链"></a><a href="#4-2-1-%E5%BB%B6%E9%95%BF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE" title="4.2.1 延长作用域链"></a>4.2.1 延长作用域链</h4><h4 id="4-2-2-没有块级作用域"><a href="#4-2-2-没有块级作用域" class="headerlink" title="4.2.2 没有块级作用域"></a><a href="#4-2-2-%E6%B2%A1%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F" title="4.2.2 没有块级作用域"></a>4.2.2 没有块级作用域</h4><h3 id="4-3-垃圾收集"><a href="#4-3-垃圾收集" class="headerlink" title="4.3 垃圾收集"></a><a href="#4-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86" title="4.3 垃圾收集"></a>4.3 垃圾收集</h3><h4 id="4-3-1-标记清除"><a href="#4-3-1-标记清除" class="headerlink" title="4.3.1 标记清除"></a><a href="#4-3-1-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4" title="4.3.1 标记清除"></a>4.3.1 标记清除</h4><h4 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2 引用计数"></a><a href="#4-3-2-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" title="4.3.2 引用计数"></a>4.3.2 引用计数</h4><h4 id="4-3-3-性能问题"><a href="#4-3-3-性能问题" class="headerlink" title="4.3.3 性能问题"></a><a href="#4-3-3-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98" title="4.3.3 性能问题"></a>4.3.3 性能问题</h4><h4 id="4-3-4-管理内存"><a href="#4-3-4-管理内存" class="headerlink" title="4.3.4 管理内存"></a><a href="#4-3-4-%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98" title="4.3.4 管理内存"></a>4.3.4 管理内存</h4><h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a><a href="#4-4-%E5%B0%8F%E7%BB%93" title="4.4 小结"></a>4.4 小结</h3><h2 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B" title="第五章 引用类型"></a>第五章 引用类型</h2><h3 id="5-1-Object类型"><a href="#5-1-Object类型" class="headerlink" title="5.1 Object类型"></a><a href="#5-1-Object%E7%B1%BB%E5%9E%8B" title="5.1 Object类型"></a>5.1 Object类型</h3><h3 id="5-2-Array类型"><a href="#5-2-Array类型" class="headerlink" title="5.2 Array类型"></a><a href="#5-2-Array%E7%B1%BB%E5%9E%8B" title="5.2 Array类型"></a>5.2 Array类型</h3><h4 id="5-2-1-检测数组"><a href="#5-2-1-检测数组" class="headerlink" title="5.2.1 检测数组"></a><a href="#5-2-1-%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84" title="5.2.1 检测数组"></a>5.2.1 检测数组</h4><h4 id="5-2-2-转换方法"><a href="#5-2-2-转换方法" class="headerlink" title="5.2.2 转换方法"></a><a href="#5-2-2-%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95" title="5.2.2 转换方法"></a>5.2.2 转换方法</h4><h4 id="5-2-3-栈方法"><a href="#5-2-3-栈方法" class="headerlink" title="5.2.3 栈方法"></a><a href="#5-2-3-%E6%A0%88%E6%96%B9%E6%B3%95" title="5.2.3 栈方法"></a>5.2.3 栈方法</h4><h4 id="5-2-4-队列方法"><a href="#5-2-4-队列方法" class="headerlink" title="5.2.4 队列方法"></a><a href="#5-2-4-%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95" title="5.2.4 队列方法"></a>5.2.4 队列方法</h4><h4 id="5-2-5-重排序方法"><a href="#5-2-5-重排序方法" class="headerlink" title="5.2.5 重排序方法"></a><a href="#5-2-5-%E9%87%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95" title="5.2.5 重排序方法"></a>5.2.5 重排序方法</h4><h4 id="5-2-6-操作方法"><a href="#5-2-6-操作方法" class="headerlink" title="5.2.6 操作方法"></a><a href="#5-2-6-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95" title="5.2.6 操作方法"></a>5.2.6 操作方法</h4><h4 id="5-2-7-位置方法"><a href="#5-2-7-位置方法" class="headerlink" title="5.2.7 位置方法"></a><a href="#5-2-7-%E4%BD%8D%E7%BD%AE%E6%96%B9%E6%B3%95" title="5.2.7 位置方法"></a>5.2.7 位置方法</h4><h4 id="5-2-8-迭代方法"><a href="#5-2-8-迭代方法" class="headerlink" title="5.2.8 迭代方法"></a><a href="#5-2-8-%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95" title="5.2.8 迭代方法"></a>5.2.8 迭代方法</h4><h4 id="5-2-9-缩小方法"><a href="#5-2-9-缩小方法" class="headerlink" title="5.2.9 缩小方法"></a><a href="#5-2-9-%E7%BC%A9%E5%B0%8F%E6%96%B9%E6%B3%95" title="5.2.9 缩小方法"></a>5.2.9 缩小方法</h4><h3 id="5-3-Date类型"><a href="#5-3-Date类型" class="headerlink" title="5.3 Date类型"></a><a href="#5-3-Date%E7%B1%BB%E5%9E%8B" title="5.3 Date类型"></a>5.3 Date类型</h3><h4 id="5-3-1-继承的方法"><a href="#5-3-1-继承的方法" class="headerlink" title="5.3.1 继承的方法"></a><a href="#5-3-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95" title="5.3.1 继承的方法"></a>5.3.1 继承的方法</h4><h4 id="5-3-2-日期格式化方法"><a href="#5-3-2-日期格式化方法" class="headerlink" title="5.3.2 日期格式化方法"></a><a href="#5-3-2-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95" title="5.3.2 日期格式化方法"></a>5.3.2 日期格式化方法</h4><h4 id="5-3-3-日期-x2F-时间组件方法"><a href="#5-3-3-日期-x2F-时间组件方法" class="headerlink" title="5.3.3 日期&#x2F;时间组件方法"></a><a href="#5-3-3-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95" title="5.3.3 日期/时间组件方法"></a>5.3.3 日期&#x2F;时间组件方法</h4><h3 id="5-4-RegExp类型"><a href="#5-4-RegExp类型" class="headerlink" title="5.4 RegExp类型"></a><a href="#5-4-RegExp%E7%B1%BB%E5%9E%8B" title="5.4 RegExp类型"></a>5.4 RegExp类型</h3><h4 id="5-4-1-RegExp实例属性"><a href="#5-4-1-RegExp实例属性" class="headerlink" title="5.4.1 RegExp实例属性"></a><a href="#5-4-1-RegExp%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" title="5.4.1 RegExp实例属性"></a>5.4.1 RegExp实例属性</h4><h4 id="5-4-2-RegExp实例方法"><a href="#5-4-2-RegExp实例方法" class="headerlink" title="5.4.2 RegExp实例方法"></a><a href="#5-4-2-RegExp%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95" title="5.4.2 RegExp实例方法"></a>5.4.2 RegExp实例方法</h4><h4 id="5-4-3-RegExp构造函数属性"><a href="#5-4-3-RegExp构造函数属性" class="headerlink" title="5.4.3 RegExp构造函数属性"></a><a href="#5-4-3-RegExp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7" title="5.4.3 RegExp构造函数属性"></a>5.4.3 RegExp构造函数属性</h4><h4 id="5-4-4-模式的局限性"><a href="#5-4-4-模式的局限性" class="headerlink" title="5.4.4 模式的局限性"></a><a href="#5-4-4-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7" title="5.4.4 模式的局限性"></a>5.4.4 模式的局限性</h4><h3 id="5-5-Function类型"><a href="#5-5-Function类型" class="headerlink" title="5.5 Function类型"></a><a href="#5-5-Function%E7%B1%BB%E5%9E%8B" title="5.5 Function类型"></a>5.5 Function类型</h3><h4 id="5-5-1-没有重载（深入理解）"><a href="#5-5-1-没有重载（深入理解）" class="headerlink" title="5.5.1 没有重载（深入理解）"></a><a href="#5-5-1-%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%89" title="5.5.1 没有重载（深入理解）"></a>5.5.1 没有重载（深入理解）</h4><h4 id="5-5-2-函数声明与表达式"><a href="#5-5-2-函数声明与表达式" class="headerlink" title="5.5.2 函数声明与表达式"></a><a href="#5-5-2-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="5.5.2 函数声明与表达式"></a>5.5.2 函数声明与表达式</h4><h4 id="5-5-3-作为值的函数"><a href="#5-5-3-作为值的函数" class="headerlink" title="5.5.3 作为值的函数"></a><a href="#5-5-3-%E4%BD%9C%E4%B8%BA%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0" title="5.5.3 作为值的函数"></a>5.5.3 作为值的函数</h4><h4 id="5-5-4-函数内部属性"><a href="#5-5-4-函数内部属性" class="headerlink" title="5.5.4 函数内部属性"></a><a href="#5-5-4-%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7" title="5.5.4 函数内部属性"></a>5.5.4 函数内部属性</h4><h4 id="5-5-5-函数属性和方法"><a href="#5-5-5-函数属性和方法" class="headerlink" title="5.5.5 函数属性和方法"></a><a href="#5-5-5-%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" title="5.5.5 函数属性和方法"></a>5.5.5 函数属性和方法</h4><h3 id="5-6-基本包装类型"><a href="#5-6-基本包装类型" class="headerlink" title="5.6 基本包装类型"></a><a href="#5-6-%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B" title="5.6 基本包装类型"></a>5.6 基本包装类型</h3><h4 id="5-6-1-Boolean类型"><a href="#5-6-1-Boolean类型" class="headerlink" title="5.6.1 Boolean类型"></a><a href="#5-6-1-Boolean%E7%B1%BB%E5%9E%8B" title="5.6.1 Boolean类型"></a>5.6.1 Boolean类型</h4><h4 id="5-6-2-Number类型"><a href="#5-6-2-Number类型" class="headerlink" title="5.6.2 Number类型"></a><a href="#5-6-2-Number%E7%B1%BB%E5%9E%8B" title="5.6.2 Number类型"></a>5.6.2 Number类型</h4><h4 id="5-6-3-String类型"><a href="#5-6-3-String类型" class="headerlink" title="5.6.3 String类型"></a><a href="#5-6-3-String%E7%B1%BB%E5%9E%8B" title="5.6.3 String类型"></a>5.6.3 String类型</h4><h3 id="5-7-单体内置对象"><a href="#5-7-单体内置对象" class="headerlink" title="5.7 单体内置对象"></a><a href="#5-7-%E5%8D%95%E4%BD%93%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1" title="5.7 单体内置对象"></a>5.7 单体内置对象</h3><h4 id="5-7-1-Global对象"><a href="#5-7-1-Global对象" class="headerlink" title="5.7.1 Global对象"></a><a href="#5-7-1-Global%E5%AF%B9%E8%B1%A1" title="5.7.1 Global对象"></a>5.7.1 Global对象</h4><h4 id="5-7-2-Math对象"><a href="#5-7-2-Math对象" class="headerlink" title="5.7.2 Math对象"></a><a href="#5-7-2-Math%E5%AF%B9%E8%B1%A1" title="5.7.2 Math对象"></a>5.7.2 Math对象</h4><h3 id="5-8-小结"><a href="#5-8-小结" class="headerlink" title="5.8 小结"></a><a href="#5-8-%E5%B0%8F%E7%BB%93" title="5.8 小结"></a>5.8 小结</h3><h2 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h2><h3 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1 理解对象"></a><a href="#6-1-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1" title="6.1 理解对象"></a>6.1 理解对象</h3><h4 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1 属性类型"></a><a href="#6-1-1-%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B" title="6.1.1 属性类型"></a>6.1.1 属性类型</h4><h4 id="6-1-2-定义多个属性"><a href="#6-1-2-定义多个属性" class="headerlink" title="6.1.2 定义多个属性"></a><a href="#6-1-2-%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7" title="6.1.2 定义多个属性"></a>6.1.2 定义多个属性</h4><h4 id="6-1-3-读取属性的特性"><a href="#6-1-3-读取属性的特性" class="headerlink" title="6.1.3 读取属性的特性"></a><a href="#6-1-3-%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7" title="6.1.3 读取属性的特性"></a>6.1.3 读取属性的特性</h4><h3 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a><a href="#6-2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1" title="6.2 创建对象"></a>6.2 创建对象</h3><h4 id="6-2-1-工厂模式"><a href="#6-2-1-工厂模式" class="headerlink" title="6.2.1 工厂模式"></a><a href="#6-2-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" title="6.2.1 工厂模式"></a>6.2.1 工厂模式</h4><h4 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2 构造函数模式"></a><a href="#6-2-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F" title="6.2.2 构造函数模式"></a>6.2.2 构造函数模式</h4><h4 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a><a href="#6-2-3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" title="6.2.3 原型模式"></a>6.2.3 原型模式</h4><h4 id="6-2-4-组合使用构造函数模式和原型模式"><a href="#6-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="6.2.4 组合使用构造函数模式和原型模式"></a><a href="#6-2-4-%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" title="6.2.4 组合使用构造函数模式和原型模式"></a>6.2.4 组合使用构造函数模式和原型模式</h4><h4 id="6-2-5-动态原型模式"><a href="#6-2-5-动态原型模式" class="headerlink" title="6.2.5 动态原型模式"></a><a href="#6-2-5-%E5%8A%A8%E6%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" title="6.2.5 动态原型模式"></a>6.2.5 动态原型模式</h4><h4 id="6-2-6-寄生构造函数模式"><a href="#6-2-6-寄生构造函数模式" class="headerlink" title="6.2.6 寄生构造函数模式"></a><a href="#6-2-6-%E5%AF%84%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F" title="6.2.6 寄生构造函数模式"></a>6.2.6 寄生构造函数模式</h4><h4 id="6-2-7-稳妥构造函数模式"><a href="#6-2-7-稳妥构造函数模式" class="headerlink" title="6.2.7 稳妥构造函数模式"></a><a href="#6-2-7-%E7%A8%B3%E5%A6%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F" title="6.2.7 稳妥构造函数模式"></a>6.2.7 稳妥构造函数模式</h4><h3 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a><a href="#6-3-%E7%BB%A7%E6%89%BF" title="6.3 继承"></a>6.3 继承</h3><h4 id="6-3-1-原型链"><a href="#6-3-1-原型链" class="headerlink" title="6.3.1 原型链"></a><a href="#6-3-1-%E5%8E%9F%E5%9E%8B%E9%93%BE" title="6.3.1 原型链"></a>6.3.1 原型链</h4><h4 id="6-3-2-借用构造函数"><a href="#6-3-2-借用构造函数" class="headerlink" title="6.3.2 借用构造函数"></a><a href="#6-3-2-%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" title="6.3.2 借用构造函数"></a>6.3.2 借用构造函数</h4><h4 id="6-3-3-组合继承"><a href="#6-3-3-组合继承" class="headerlink" title="6.3.3 组合继承"></a><a href="#6-3-3-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF" title="6.3.3 组合继承"></a>6.3.3 组合继承</h4><h4 id="6-3-4-原型式继承"><a href="#6-3-4-原型式继承" class="headerlink" title="6.3.4 原型式继承"></a><a href="#6-3-4-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF" title="6.3.4 原型式继承"></a>6.3.4 原型式继承</h4><h4 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5 寄生式继承"></a><a href="#6-3-5-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF" title="6.3.5 寄生式继承"></a>6.3.5 寄生式继承</h4><h4 id="6-3-6-寄生组合式继承"><a href="#6-3-6-寄生组合式继承" class="headerlink" title="6.3.6 寄生组合式继承"></a><a href="#6-3-6-%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF" title="6.3.6 寄生组合式继承"></a>6.3.6 寄生组合式继承</h4><h3 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a><a href="#6-4-%E5%B0%8F%E7%BB%93" title="6.4 小结"></a>6.4 小结</h3><h2 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="第七章 函数表达式"></a>第七章 函数表达式</h2><h3 id="7-1-递归"><a href="#7-1-递归" class="headerlink" title="7.1 递归"></a><a href="#7-1-%E9%80%92%E5%BD%92" title="7.1 递归"></a>7.1 递归</h3><h3 id="7-2-闭包"><a href="#7-2-闭包" class="headerlink" title="7.2 闭包"></a><a href="#7-2-%E9%97%AD%E5%8C%85" title="7.2 闭包"></a>7.2 闭包</h3><h4 id="7-2-1-闭包与变量"><a href="#7-2-1-闭包与变量" class="headerlink" title="7.2.1 闭包与变量"></a><a href="#7-2-1-%E9%97%AD%E5%8C%85%E4%B8%8E%E5%8F%98%E9%87%8F" title="7.2.1 闭包与变量"></a>7.2.1 闭包与变量</h4><h4 id="7-2-2-关于this对象"><a href="#7-2-2-关于this对象" class="headerlink" title="7.2.2 关于this对象"></a><a href="#7-2-2-%E5%85%B3%E4%BA%8Ethis%E5%AF%B9%E8%B1%A1" title="7.2.2 关于this对象"></a>7.2.2 关于this对象</h4><h4 id="7-2-3-内存泄漏"><a href="#7-2-3-内存泄漏" class="headerlink" title="7.2.3 内存泄漏"></a><a href="#7-2-3-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" title="7.2.3 内存泄漏"></a>7.2.3 内存泄漏</h4><h3 id="7-3-模仿块级作用域"><a href="#7-3-模仿块级作用域" class="headerlink" title="7.3 模仿块级作用域"></a><a href="#7-3-%E6%A8%A1%E4%BB%BF%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F" title="7.3 模仿块级作用域"></a>7.3 模仿块级作用域</h3><h3 id="7-4-私有变量"><a href="#7-4-私有变量" class="headerlink" title="7.4 私有变量"></a><a href="#7-4-%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F" title="7.4 私有变量"></a>7.4 私有变量</h3><h4 id="7-4-1-静态私有变量"><a href="#7-4-1-静态私有变量" class="headerlink" title="7.4.1 静态私有变量"></a><a href="#7-4-1-%E9%9D%99%E6%80%81%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F" title="7.4.1 静态私有变量"></a>7.4.1 静态私有变量</h4><h4 id="7-4-2-模块模式"><a href="#7-4-2-模块模式" class="headerlink" title="7.4.2 模块模式"></a><a href="#7-4-2-%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F" title="7.4.2 模块模式"></a>7.4.2 模块模式</h4><h4 id="7-4-3-增强的模块模式"><a href="#7-4-3-增强的模块模式" class="headerlink" title="7.4.3 增强的模块模式"></a><a href="#7-4-3-%E5%A2%9E%E5%BC%BA%E7%9A%84%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F" title="7.4.3 增强的模块模式"></a>7.4.3 增强的模块模式</h4><h3 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5 小结"></a><a href="#7-5-%E5%B0%8F%E7%BB%93" title="7.5 小结"></a>7.5 小结</h3><h2 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章  BOM"></a><a href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-BOM" title="第八章  BOM"></a>第八章  BOM</h2><h3 id="8-1-window对象"><a href="#8-1-window对象" class="headerlink" title="8.1 window对象"></a><a href="#8-1-window%E5%AF%B9%E8%B1%A1" title="8.1 window对象"></a>8.1 window对象</h3><h4 id="8-1-1-全局作用域"><a href="#8-1-1-全局作用域" class="headerlink" title="8.1.1 全局作用域"></a><a href="#8-1-1-%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F" title="8.1.1 全局作用域"></a>8.1.1 全局作用域</h4><h4 id="8-1-2-窗口关系及框架"><a href="#8-1-2-窗口关系及框架" class="headerlink" title="8.1.2 窗口关系及框架"></a><a href="#8-1-2-%E7%AA%97%E5%8F%A3%E5%85%B3%E7%B3%BB%E5%8F%8A%E6%A1%86%E6%9E%B6" title="8.1.2 窗口关系及框架"></a>8.1.2 窗口关系及框架</h4><h4 id="8-1-3-窗口位置"><a href="#8-1-3-窗口位置" class="headerlink" title="8.1.3 窗口位置"></a><a href="#8-1-3-%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE" title="8.1.3 窗口位置"></a>8.1.3 窗口位置</h4><h4 id="8-1-4-窗口大小"><a href="#8-1-4-窗口大小" class="headerlink" title="8.1.4 窗口大小"></a><a href="#8-1-4-%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F" title="8.1.4 窗口大小"></a>8.1.4 窗口大小</h4><h4 id="8-1-5-导航和打开窗口"><a href="#8-1-5-导航和打开窗口" class="headerlink" title="8.1.5 导航和打开窗口"></a><a href="#8-1-5-%E5%AF%BC%E8%88%AA%E5%92%8C%E6%89%93%E5%BC%80%E7%AA%97%E5%8F%A3" title="8.1.5 导航和打开窗口"></a>8.1.5 导航和打开窗口</h4><h4 id="8-1-6-间歇调用和超时调用"><a href="#8-1-6-间歇调用和超时调用" class="headerlink" title="8.1.6 间歇调用和超时调用"></a><a href="#8-1-6-%E9%97%B4%E6%AD%87%E8%B0%83%E7%94%A8%E5%92%8C%E8%B6%85%E6%97%B6%E8%B0%83%E7%94%A8" title="8.1.6 间歇调用和超时调用"></a>8.1.6 间歇调用和超时调用</h4><h4 id="8-1-7-系统对话框"><a href="#8-1-7-系统对话框" class="headerlink" title="8.1.7 系统对话框"></a><a href="#8-1-7-%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86" title="8.1.7 系统对话框"></a>8.1.7 系统对话框</h4><h3 id="8-2-location对象"><a href="#8-2-location对象" class="headerlink" title="8.2 location对象"></a><a href="#8-2-location%E5%AF%B9%E8%B1%A1" title="8.2 location对象"></a>8.2 location对象</h3><h4 id="8-2-1-查询字符串参数"><a href="#8-2-1-查询字符串参数" class="headerlink" title="8.2.1 查询字符串参数"></a><a href="#8-2-1-%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%82%E6%95%B0" title="8.2.1 查询字符串参数"></a>8.2.1 查询字符串参数</h4><h4 id="8-2-2-位置操作"><a href="#8-2-2-位置操作" class="headerlink" title="8.2.2 位置操作"></a><a href="#8-2-2-%E4%BD%8D%E7%BD%AE%E6%93%8D%E4%BD%9C" title="8.2.2 位置操作"></a>8.2.2 位置操作</h4><h3 id="8-3-navigator对象"><a href="#8-3-navigator对象" class="headerlink" title="8.3 navigator对象"></a><a href="#8-3-navigator%E5%AF%B9%E8%B1%A1" title="8.3 navigator对象"></a>8.3 navigator对象</h3><h4 id="8-3-1-检测插件"><a href="#8-3-1-检测插件" class="headerlink" title="8.3.1 检测插件"></a><a href="#8-3-1-%E6%A3%80%E6%B5%8B%E6%8F%92%E4%BB%B6" title="8.3.1 检测插件"></a>8.3.1 检测插件</h4><h4 id="8-3-2-注册处理程序"><a href="#8-3-2-注册处理程序" class="headerlink" title="8.3.2 注册处理程序"></a><a href="#8-3-2-%E6%B3%A8%E5%86%8C%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" title="8.3.2 注册处理程序"></a>8.3.2 注册处理程序</h4><h3 id="8-4-screen对象"><a href="#8-4-screen对象" class="headerlink" title="8.4 screen对象"></a><a href="#8-4-screen%E5%AF%B9%E8%B1%A1" title="8.4 screen对象"></a>8.4 screen对象</h3><h3 id="8-5-history对象"><a href="#8-5-history对象" class="headerlink" title="8.5 history对象"></a><a href="#8-5-history%E5%AF%B9%E8%B1%A1" title="8.5 history对象"></a>8.5 history对象</h3><h3 id="8-6-小结"><a href="#8-6-小结" class="headerlink" title="8.6 小结"></a><a href="#8-6-%E5%B0%8F%E7%BB%93" title="8.6 小结"></a>8.6 小结</h3><h2 id="第九章-客户端检测"><a href="#第九章-客户端检测" class="headerlink" title="第九章 客户端检测"></a><a href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B" title="第九章 客户端检测"></a>第九章 客户端检测</h2><h3 id="9-1-能力检测"><a href="#9-1-能力检测" class="headerlink" title="9.1 能力检测"></a><a href="#9-1-%E8%83%BD%E5%8A%9B%E6%A3%80%E6%B5%8B" title="9.1 能力检测"></a>9.1 能力检测</h3><h4 id="9-1-1-更可靠的能力检测"><a href="#9-1-1-更可靠的能力检测" class="headerlink" title="9.1.1 更可靠的能力检测"></a><a href="#9-1-1-%E6%9B%B4%E5%8F%AF%E9%9D%A0%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A3%80%E6%B5%8B" title="9.1.1 更可靠的能力检测"></a>9.1.1 更可靠的能力检测</h4><h4 id="9-1-2-能力检测，不是浏览器检测"><a href="#9-1-2-能力检测，不是浏览器检测" class="headerlink" title="9.1.2 能力检测，不是浏览器检测"></a><a href="#9-1-2-%E8%83%BD%E5%8A%9B%E6%A3%80%E6%B5%8B%EF%BC%8C%E4%B8%8D%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A3%80%E6%B5%8B" title="9.1.2 能力检测，不是浏览器检测"></a>9.1.2 能力检测，不是浏览器检测</h4><h3 id="9-2-怪癖检测"><a href="#9-2-怪癖检测" class="headerlink" title="9.2 怪癖检测"></a><a href="#9-2-%E6%80%AA%E7%99%96%E6%A3%80%E6%B5%8B" title="9.2 怪癖检测"></a>9.2 怪癖检测</h3><h3 id="9-3-用户代理检测"><a href="#9-3-用户代理检测" class="headerlink" title="9.3 用户代理检测"></a><a href="#9-3-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E6%A3%80%E6%B5%8B" title="9.3 用户代理检测"></a>9.3 用户代理检测</h3><h4 id="9-3-1-用户代理字符串的历史"><a href="#9-3-1-用户代理字符串的历史" class="headerlink" title="9.3.1 用户代理字符串的历史"></a><a href="#9-3-1-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8E%86%E5%8F%B2" title="9.3.1 用户代理字符串的历史"></a>9.3.1 用户代理字符串的历史</h4><h4 id="9-3-2-用户代理字符串检测技术"><a href="#9-3-2-用户代理字符串检测技术" class="headerlink" title="9.3.2 用户代理字符串检测技术"></a><a href="#9-3-2-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF" title="9.3.2 用户代理字符串检测技术"></a>9.3.2 用户代理字符串检测技术</h4><h4 id="9-3-3-完整的代码"><a href="#9-3-3-完整的代码" class="headerlink" title="9.3.3 完整的代码"></a><a href="#9-3-3-%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%A0%81" title="9.3.3 完整的代码"></a>9.3.3 完整的代码</h4><h4 id="9-3-4-使用方法"><a href="#9-3-4-使用方法" class="headerlink" title="9.3.4 使用方法"></a><a href="#9-3-4-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" title="9.3.4 使用方法"></a>9.3.4 使用方法</h4><h3 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a><a href="#9-4-%E5%B0%8F%E7%BB%93" title="9.4 小结"></a>9.4 小结</h3><h2 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a><a href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-DOM" title="第十章 DOM"></a>第十章 DOM</h2><h3 id="10-1-节点层次"><a href="#10-1-节点层次" class="headerlink" title="10.1 节点层次"></a><a href="#10-1-%E8%8A%82%E7%82%B9%E5%B1%82%E6%AC%A1" title="10.1 节点层次"></a>10.1 节点层次</h3><h4 id="10-1-1-Node类型"><a href="#10-1-1-Node类型" class="headerlink" title="10.1.1 Node类型"></a><a href="#10-1-1-Node%E7%B1%BB%E5%9E%8B" title="10.1.1 Node类型"></a>10.1.1 Node类型</h4><h4 id="10-1-2-Document类型"><a href="#10-1-2-Document类型" class="headerlink" title="10.1.2 Document类型"></a><a href="#10-1-2-Document%E7%B1%BB%E5%9E%8B" title="10.1.2 Document类型"></a>10.1.2 Document类型</h4><h4 id="10-1-3-Element类型"><a href="#10-1-3-Element类型" class="headerlink" title="10.1.3 Element类型"></a><a href="#10-1-3-Element%E7%B1%BB%E5%9E%8B" title="10.1.3 Element类型"></a>10.1.3 Element类型</h4><h4 id="10-1-4-Text类型"><a href="#10-1-4-Text类型" class="headerlink" title="10.1.4 Text类型"></a><a href="#10-1-4-Text%E7%B1%BB%E5%9E%8B" title="10.1.4 Text类型"></a>10.1.4 Text类型</h4><h4 id="10-1-5-Comment类型"><a href="#10-1-5-Comment类型" class="headerlink" title="10.1.5 Comment类型"></a><a href="#10-1-5-Comment%E7%B1%BB%E5%9E%8B" title="10.1.5 Comment类型"></a>10.1.5 Comment类型</h4><h4 id="10-1-6-CDATASection类型"><a href="#10-1-6-CDATASection类型" class="headerlink" title="10.1.6 CDATASection类型"></a><a href="#10-1-6-CDATASection%E7%B1%BB%E5%9E%8B" title="10.1.6 CDATASection类型"></a>10.1.6 CDATASection类型</h4><h4 id="10-1-7-DocumentType类型"><a href="#10-1-7-DocumentType类型" class="headerlink" title="10.1.7 DocumentType类型"></a><a href="#10-1-7-DocumentType%E7%B1%BB%E5%9E%8B" title="10.1.7 DocumentType类型"></a>10.1.7 DocumentType类型</h4><h4 id="10-1-8-DocumentFragment类型"><a href="#10-1-8-DocumentFragment类型" class="headerlink" title="10.1.8 DocumentFragment类型"></a><a href="#10-1-8-DocumentFragment%E7%B1%BB%E5%9E%8B" title="10.1.8 DocumentFragment类型"></a>10.1.8 DocumentFragment类型</h4><h4 id="10-1-9-Attr类型"><a href="#10-1-9-Attr类型" class="headerlink" title="10.1.9 Attr类型"></a><a href="#10-1-9-Attr%E7%B1%BB%E5%9E%8B" title="10.1.9 Attr类型"></a>10.1.9 Attr类型</h4><h3 id="10-2-DOM操作技术"><a href="#10-2-DOM操作技术" class="headerlink" title="10.2 DOM操作技术"></a><a href="#10-2-DOM%E6%93%8D%E4%BD%9C%E6%8A%80%E6%9C%AF" title="10.2 DOM操作技术"></a>10.2 DOM操作技术</h3><h4 id="10-2-1-动态脚本"><a href="#10-2-1-动态脚本" class="headerlink" title="10.2.1 动态脚本"></a><a href="#10-2-1-%E5%8A%A8%E6%80%81%E8%84%9A%E6%9C%AC" title="10.2.1 动态脚本"></a>10.2.1 动态脚本</h4><h4 id="10-2-2-动态样式"><a href="#10-2-2-动态样式" class="headerlink" title="10.2.2 动态样式"></a><a href="#10-2-2-%E5%8A%A8%E6%80%81%E6%A0%B7%E5%BC%8F" title="10.2.2 动态样式"></a>10.2.2 动态样式</h4><h4 id="10-2-3-操作表格"><a href="#10-2-3-操作表格" class="headerlink" title="10.2.3 操作表格"></a><a href="#10-2-3-%E6%93%8D%E4%BD%9C%E8%A1%A8%E6%A0%BC" title="10.2.3 操作表格"></a>10.2.3 操作表格</h4><h4 id="10-2-4-使用NodeList"><a href="#10-2-4-使用NodeList" class="headerlink" title="10.2.4 使用NodeList"></a><a href="#10-2-4-%E4%BD%BF%E7%94%A8NodeList" title="10.2.4 使用NodeList"></a>10.2.4 使用NodeList</h4><h3 id="10-3-小结"><a href="#10-3-小结" class="headerlink" title="10.3 小结"></a><a href="#10-3-%E5%B0%8F%E7%BB%93" title="10.3 小结"></a>10.3 小结</h3><h2 id="第十一章-DOM扩展"><a href="#第十一章-DOM扩展" class="headerlink" title="第十一章 DOM扩展"></a><a href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-DOM%E6%89%A9%E5%B1%95" title="第十一章 DOM扩展"></a>第十一章 DOM扩展</h2><h3 id="11-1-选择符API"><a href="#11-1-选择符API" class="headerlink" title="11.1 选择符API"></a><a href="#11-1-%E9%80%89%E6%8B%A9%E7%AC%A6API" title="11.1 选择符API"></a>11.1 选择符API</h3><h4 id="11-1-1-querySelector-方法"><a href="#11-1-1-querySelector-方法" class="headerlink" title="11.1.1 querySelector()方法"></a><a href="#11-1-1-querySelector-%E6%96%B9%E6%B3%95" title="11.1.1 querySelector()方法"></a>11.1.1 querySelector()方法</h4><h4 id="11-1-2-querySelectorAll-方法"><a href="#11-1-2-querySelectorAll-方法" class="headerlink" title="11.1.2 querySelectorAll()方法"></a><a href="#11-1-2-querySelectorAll-%E6%96%B9%E6%B3%95" title="11.1.2 querySelectorAll()方法"></a>11.1.2 querySelectorAll()方法</h4><h4 id="11-1-3-matchesSelector-方法"><a href="#11-1-3-matchesSelector-方法" class="headerlink" title="11.1.3 matchesSelector()方法"></a><a href="#11-1-3-matchesSelector-%E6%96%B9%E6%B3%95" title="11.1.3 matchesSelector()方法"></a>11.1.3 matchesSelector()方法</h4><h3 id="11-2-元素遍历"><a href="#11-2-元素遍历" class="headerlink" title="11.2 元素遍历"></a><a href="#11-2-%E5%85%83%E7%B4%A0%E9%81%8D%E5%8E%86" title="11.2 元素遍历"></a>11.2 元素遍历</h3><h3 id="11-3-HTML5"><a href="#11-3-HTML5" class="headerlink" title="11.3 HTML5"></a><a href="#11-3-HTML5" title="11.3 HTML5"></a>11.3 HTML5</h3><h4 id="11-3-1-与类相关的扩充"><a href="#11-3-1-与类相关的扩充" class="headerlink" title="11.3.1 与类相关的扩充"></a><a href="#11-3-1-%E4%B8%8E%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E6%89%A9%E5%85%85" title="11.3.1 与类相关的扩充"></a>11.3.1 与类相关的扩充</h4><h4 id="11-3-2-焦点管理"><a href="#11-3-2-焦点管理" class="headerlink" title="11.3.2 焦点管理"></a><a href="#11-3-2-%E7%84%A6%E7%82%B9%E7%AE%A1%E7%90%86" title="11.3.2 焦点管理"></a>11.3.2 焦点管理</h4><h4 id="11-3-3-HTMLDocument的变化"><a href="#11-3-3-HTMLDocument的变化" class="headerlink" title="11.3.3 HTMLDocument的变化"></a><a href="#11-3-3-HTMLDocument%E7%9A%84%E5%8F%98%E5%8C%96" title="11.3.3 HTMLDocument的变化"></a>11.3.3 HTMLDocument的变化</h4><h4 id="11-3-4-字符集属性"><a href="#11-3-4-字符集属性" class="headerlink" title="11.3.4 字符集属性"></a><a href="#11-3-4-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%B1%9E%E6%80%A7" title="11.3.4 字符集属性"></a>11.3.4 字符集属性</h4><h4 id="11-3-5-自定义数据属性"><a href="#11-3-5-自定义数据属性" class="headerlink" title="11.3.5 自定义数据属性"></a><a href="#11-3-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7" title="11.3.5 自定义数据属性"></a>11.3.5 自定义数据属性</h4><h4 id="11-3-6-插入标记"><a href="#11-3-6-插入标记" class="headerlink" title="11.3.6 插入标记"></a><a href="#11-3-6-%E6%8F%92%E5%85%A5%E6%A0%87%E8%AE%B0" title="11.3.6 插入标记"></a>11.3.6 插入标记</h4><h4 id="11-3-7-scrollIntoView-方法"><a href="#11-3-7-scrollIntoView-方法" class="headerlink" title="11.3.7 scrollIntoView()方法"></a><a href="#11-3-7-scrollIntoView-%E6%96%B9%E6%B3%95" title="11.3.7 scrollIntoView()方法"></a>11.3.7 scrollIntoView()方法</h4><h3 id="11-4-专有扩展"><a href="#11-4-专有扩展" class="headerlink" title="11.4 专有扩展"></a><a href="#11-4-%E4%B8%93%E6%9C%89%E6%89%A9%E5%B1%95" title="11.4 专有扩展"></a>11.4 专有扩展</h3><h4 id="11-4-1-文档模式"><a href="#11-4-1-文档模式" class="headerlink" title="11.4.1 文档模式"></a><a href="#11-4-1-%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F" title="11.4.1 文档模式"></a>11.4.1 文档模式</h4><h4 id="11-4-2-children属性"><a href="#11-4-2-children属性" class="headerlink" title="11.4.2 children属性"></a><a href="#11-4-2-children%E5%B1%9E%E6%80%A7" title="11.4.2 children属性"></a>11.4.2 children属性</h4><h4 id="11-4-3-contains-方法"><a href="#11-4-3-contains-方法" class="headerlink" title="11.4.3 contains()方法"></a><a href="#11-4-3-contains-%E6%96%B9%E6%B3%95" title="11.4.3 contains()方法"></a>11.4.3 contains()方法</h4><h4 id="11-4-4-插入文本"><a href="#11-4-4-插入文本" class="headerlink" title="11.4.4 插入文本"></a><a href="#11-4-4-%E6%8F%92%E5%85%A5%E6%96%87%E6%9C%AC" title="11.4.4 插入文本"></a>11.4.4 插入文本</h4><h4 id="11-4-5-滚动"><a href="#11-4-5-滚动" class="headerlink" title="11.4.5 滚动"></a><a href="#11-4-5-%E6%BB%9A%E5%8A%A8" title="11.4.5 滚动"></a>11.4.5 滚动</h4><h3 id="11-5-小结"><a href="#11-5-小结" class="headerlink" title="11.5 小结"></a><a href="#11-5-%E5%B0%8F%E7%BB%93" title="11.5 小结"></a>11.5 小结</h3><h2 id="第十二章-DOM2和DOM3"><a href="#第十二章-DOM2和DOM3" class="headerlink" title="第十二章 DOM2和DOM3"></a><a href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-DOM2%E5%92%8CDOM3" title="第十二章 DOM2和DOM3"></a>第十二章 DOM2和DOM3</h2><h3 id="12-1-DOM变化"><a href="#12-1-DOM变化" class="headerlink" title="12.1 DOM变化"></a><a href="#12-1-DOM%E5%8F%98%E5%8C%96" title="12.1 DOM变化"></a>12.1 DOM变化</h3><h4 id="12-1-1-针对XML命名空间的变化"><a href="#12-1-1-针对XML命名空间的变化" class="headerlink" title="12.1.1 针对XML命名空间的变化"></a><a href="#12-1-1-%E9%92%88%E5%AF%B9XML%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E5%8C%96" title="12.1.1 针对XML命名空间的变化"></a>12.1.1 针对XML命名空间的变化</h4><h4 id="12-1-2-其他方面的变化"><a href="#12-1-2-其他方面的变化" class="headerlink" title="12.1.2 其他方面的变化"></a><a href="#12-1-2-%E5%85%B6%E4%BB%96%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8F%98%E5%8C%96" title="12.1.2 其他方面的变化"></a>12.1.2 其他方面的变化</h4><h3 id="12-2-样式"><a href="#12-2-样式" class="headerlink" title="12.2 样式"></a><a href="#12-2-%E6%A0%B7%E5%BC%8F" title="12.2 样式"></a>12.2 样式</h3><h4 id="12-2-1-访问元素的样式"><a href="#12-2-1-访问元素的样式" class="headerlink" title="12.2.1 访问元素的样式"></a><a href="#12-2-1-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F" title="12.2.1 访问元素的样式"></a>12.2.1 访问元素的样式</h4><h4 id="12-2-2-操作样式表"><a href="#12-2-2-操作样式表" class="headerlink" title="12.2.2 操作样式表"></a><a href="#12-2-2-%E6%93%8D%E4%BD%9C%E6%A0%B7%E5%BC%8F%E8%A1%A8" title="12.2.2 操作样式表"></a>12.2.2 操作样式表</h4><h4 id="12-2-3-元素大小"><a href="#12-2-3-元素大小" class="headerlink" title="12.2.3 元素大小"></a><a href="#12-2-3-%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F" title="12.2.3 元素大小"></a>12.2.3 元素大小</h4><h3 id="12-3-遍历"><a href="#12-3-遍历" class="headerlink" title="12.3 遍历"></a><a href="#12-3-%E9%81%8D%E5%8E%86" title="12.3 遍历"></a>12.3 遍历</h3><h4 id="12-3-1-NodeIterator"><a href="#12-3-1-NodeIterator" class="headerlink" title="12.3.1 NodeIterator"></a><a href="#12-3-1-NodeIterator" title="12.3.1 NodeIterator"></a>12.3.1 NodeIterator</h4><h4 id="12-3-2-TreeWalker"><a href="#12-3-2-TreeWalker" class="headerlink" title="12.3.2 TreeWalker"></a><a href="#12-3-2-TreeWalker" title="12.3.2 TreeWalker"></a>12.3.2 TreeWalker</h4><h3 id="12-4-范围"><a href="#12-4-范围" class="headerlink" title="12.4 范围"></a><a href="#12-4-%E8%8C%83%E5%9B%B4" title="12.4 范围"></a>12.4 范围</h3><h4 id="12-4-1-DOM中的范围"><a href="#12-4-1-DOM中的范围" class="headerlink" title="12.4.1 DOM中的范围"></a><a href="#12-4-1-DOM%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9B%B4" title="12.4.1 DOM中的范围"></a>12.4.1 DOM中的范围</h4><h4 id="12-4-2-IE8及更早版本中的范围"><a href="#12-4-2-IE8及更早版本中的范围" class="headerlink" title="12.4.2 IE8及更早版本中的范围"></a><a href="#12-4-2-IE8%E5%8F%8A%E6%9B%B4%E6%97%A9%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9B%B4" title="12.4.2 IE8及更早版本中的范围"></a>12.4.2 IE8及更早版本中的范围</h4><h3 id="12-5-小结"><a href="#12-5-小结" class="headerlink" title="12.5 小结"></a><a href="#12-5-%E5%B0%8F%E7%BB%93" title="12.5 小结"></a>12.5 小结</h3><h2 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a><a href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E4%BA%8B%E4%BB%B6" title="第十三章 事件"></a>第十三章 事件</h2><h3 id="13-1-事件流"><a href="#13-1-事件流" class="headerlink" title="13.1 事件流"></a><a href="#13-1-%E4%BA%8B%E4%BB%B6%E6%B5%81" title="13.1 事件流"></a>13.1 事件流</h3><h4 id="13-1-1-事件冒泡"><a href="#13-1-1-事件冒泡" class="headerlink" title="13.1.1 事件冒泡"></a><a href="#13-1-1-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1" title="13.1.1 事件冒泡"></a>13.1.1 事件冒泡</h4><h4 id="13-1-2-事件捕获"><a href="#13-1-2-事件捕获" class="headerlink" title="13.1.2 事件捕获"></a><a href="#13-1-2-%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7" title="13.1.2 事件捕获"></a>13.1.2 事件捕获</h4><h4 id="13-1-3-DOM事件流"><a href="#13-1-3-DOM事件流" class="headerlink" title="13.1.3 DOM事件流"></a><a href="#13-1-3-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81" title="13.1.3 DOM事件流"></a>13.1.3 DOM事件流</h4><h3 id="13-2-事件处理程序"><a href="#13-2-事件处理程序" class="headerlink" title="13.2 事件处理程序"></a><a href="#13-2-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" title="13.2 事件处理程序"></a>13.2 事件处理程序</h3><h4 id="13-2-1-HTML事件处理程序"><a href="#13-2-1-HTML事件处理程序" class="headerlink" title="13.2.1 HTML事件处理程序"></a><a href="#13-2-1-HTML%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" title="13.2.1 HTML事件处理程序"></a>13.2.1 HTML事件处理程序</h4><h4 id="13-2-2-DOM0级事件处理程序"><a href="#13-2-2-DOM0级事件处理程序" class="headerlink" title="13.2.2 DOM0级事件处理程序"></a><a href="#13-2-2-DOM0%E7%BA%A7%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" title="13.2.2 DOM0级事件处理程序"></a>13.2.2 DOM0级事件处理程序</h4><h4 id="13-2-3-DOM2级事件处理程序"><a href="#13-2-3-DOM2级事件处理程序" class="headerlink" title="13.2.3 DOM2级事件处理程序"></a><a href="#13-2-3-DOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" title="13.2.3 DOM2级事件处理程序"></a>13.2.3 DOM2级事件处理程序</h4><h4 id="13-2-4-IE事件处理程序"><a href="#13-2-4-IE事件处理程序" class="headerlink" title="13.2.4 IE事件处理程序"></a><a href="#13-2-4-IE%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" title="13.2.4 IE事件处理程序"></a>13.2.4 IE事件处理程序</h4><h4 id="13-2-5-跨浏览器的事件处理程序"><a href="#13-2-5-跨浏览器的事件处理程序" class="headerlink" title="13.2.5 跨浏览器的事件处理程序"></a><a href="#13-2-5-%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" title="13.2.5 跨浏览器的事件处理程序"></a>13.2.5 跨浏览器的事件处理程序</h4><h3 id="13-3-事件对象"><a href="#13-3-事件对象" class="headerlink" title="13.3 事件对象"></a><a href="#13-3-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1" title="13.3 事件对象"></a>13.3 事件对象</h3><h4 id="13-3-1-DOM中的事件对象"><a href="#13-3-1-DOM中的事件对象" class="headerlink" title="13.3.1 DOM中的事件对象"></a><a href="#13-3-1-DOM%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1" title="13.3.1 DOM中的事件对象"></a>13.3.1 DOM中的事件对象</h4><h4 id="13-3-2-IE中的事件对象"><a href="#13-3-2-IE中的事件对象" class="headerlink" title="13.3.2 IE中的事件对象"></a><a href="#13-3-2-IE%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1" title="13.3.2 IE中的事件对象"></a>13.3.2 IE中的事件对象</h4><h4 id="13-3-3-跨浏览器的事件对象"><a href="#13-3-3-跨浏览器的事件对象" class="headerlink" title="13.3.3 跨浏览器的事件对象"></a><a href="#13-3-3-%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1" title="13.3.3 跨浏览器的事件对象"></a>13.3.3 跨浏览器的事件对象</h4><h3 id="13-4-事件类型"><a href="#13-4-事件类型" class="headerlink" title="13.4 事件类型"></a><a href="#13-4-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B" title="13.4 事件类型"></a>13.4 事件类型</h3><h4 id="13-4-1-UI事件"><a href="#13-4-1-UI事件" class="headerlink" title="13.4.1 UI事件"></a><a href="#13-4-1-UI%E4%BA%8B%E4%BB%B6" title="13.4.1 UI事件"></a>13.4.1 UI事件</h4><h4 id="13-4-2-焦点事件"><a href="#13-4-2-焦点事件" class="headerlink" title="13.4.2 焦点事件"></a><a href="#13-4-2-%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6" title="13.4.2 焦点事件"></a>13.4.2 焦点事件</h4><h4 id="13-4-3-鼠标与滚轮事件"><a href="#13-4-3-鼠标与滚轮事件" class="headerlink" title="13.4.3 鼠标与滚轮事件"></a><a href="#13-4-3-%E9%BC%A0%E6%A0%87%E4%B8%8E%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6" title="13.4.3 鼠标与滚轮事件"></a>13.4.3 鼠标与滚轮事件</h4><h4 id="13-4-4-键盘与文本事件"><a href="#13-4-4-键盘与文本事件" class="headerlink" title="13.4.4 键盘与文本事件"></a><a href="#13-4-4-%E9%94%AE%E7%9B%98%E4%B8%8E%E6%96%87%E6%9C%AC%E4%BA%8B%E4%BB%B6" title="13.4.4 键盘与文本事件"></a>13.4.4 键盘与文本事件</h4><h4 id="13-4-5-复合事件"><a href="#13-4-5-复合事件" class="headerlink" title="13.4.5 复合事件"></a><a href="#13-4-5-%E5%A4%8D%E5%90%88%E4%BA%8B%E4%BB%B6" title="13.4.5 复合事件"></a>13.4.5 复合事件</h4><h4 id="13-4-6-变动事件"><a href="#13-4-6-变动事件" class="headerlink" title="13.4.6 变动事件"></a><a href="#13-4-6-%E5%8F%98%E5%8A%A8%E4%BA%8B%E4%BB%B6" title="13.4.6 变动事件"></a>13.4.6 变动事件</h4><h4 id="13-4-7-HTML5事件"><a href="#13-4-7-HTML5事件" class="headerlink" title="13.4.7 HTML5事件"></a><a href="#13-4-7-HTML5%E4%BA%8B%E4%BB%B6" title="13.4.7 HTML5事件"></a>13.4.7 HTML5事件</h4><h4 id="13-4-8-设备事件"><a href="#13-4-8-设备事件" class="headerlink" title="13.4.8 设备事件"></a><a href="#13-4-8-%E8%AE%BE%E5%A4%87%E4%BA%8B%E4%BB%B6" title="13.4.8 设备事件"></a>13.4.8 设备事件</h4><h4 id="13-4-9-触摸与手势事件"><a href="#13-4-9-触摸与手势事件" class="headerlink" title="13.4.9 触摸与手势事件"></a><a href="#13-4-9-%E8%A7%A6%E6%91%B8%E4%B8%8E%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6" title="13.4.9 触摸与手势事件"></a>13.4.9 触摸与手势事件</h4><h3 id="13-5-内存和性能"><a href="#13-5-内存和性能" class="headerlink" title="13.5 内存和性能"></a><a href="#13-5-%E5%86%85%E5%AD%98%E5%92%8C%E6%80%A7%E8%83%BD" title="13.5 内存和性能"></a>13.5 内存和性能</h3><h4 id="13-5-1-事件委托"><a href="#13-5-1-事件委托" class="headerlink" title="13.5.1 事件委托"></a><a href="#13-5-1-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98" title="13.5.1 事件委托"></a>13.5.1 事件委托</h4><h4 id="13-5-2-移除事件处理程序"><a href="#13-5-2-移除事件处理程序" class="headerlink" title="13.5.2 移除事件处理程序"></a><a href="#13-5-2-%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" title="13.5.2 移除事件处理程序"></a>13.5.2 移除事件处理程序</h4><h3 id="13-6-模拟事件"><a href="#13-6-模拟事件" class="headerlink" title="13.6 模拟事件"></a><a href="#13-6-%E6%A8%A1%E6%8B%9F%E4%BA%8B%E4%BB%B6" title="13.6 模拟事件"></a>13.6 模拟事件</h3><h4 id="13-6-1-DOM中的事件模拟"><a href="#13-6-1-DOM中的事件模拟" class="headerlink" title="13.6.1 DOM中的事件模拟"></a><a href="#13-6-1-DOM%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E6%8B%9F" title="13.6.1 DOM中的事件模拟"></a>13.6.1 DOM中的事件模拟</h4><h4 id="13-6-2-IE中的事件模拟"><a href="#13-6-2-IE中的事件模拟" class="headerlink" title="13.6.2 IE中的事件模拟"></a><a href="#13-6-2-IE%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E6%8B%9F" title="13.6.2 IE中的事件模拟"></a>13.6.2 IE中的事件模拟</h4><h3 id="13-7-小结"><a href="#13-7-小结" class="headerlink" title="13.7 小结"></a><a href="#13-7-%E5%B0%8F%E7%BB%93" title="13.7 小结"></a>13.7 小结</h3><h2 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a><a href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC" title="第十四章 表单脚本"></a>第十四章 表单脚本</h2><h3 id="14-1-表单的基础知识"><a href="#14-1-表单的基础知识" class="headerlink" title="14.1 表单的基础知识"></a><a href="#14-1-%E8%A1%A8%E5%8D%95%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" title="14.1 表单的基础知识"></a>14.1 表单的基础知识</h3><h4 id="14-1-1-提交表单"><a href="#14-1-1-提交表单" class="headerlink" title="14.1.1 提交表单"></a><a href="#14-1-1-%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95" title="14.1.1 提交表单"></a>14.1.1 提交表单</h4><h4 id="14-1-2-重置表单"><a href="#14-1-2-重置表单" class="headerlink" title="14.1.2 重置表单"></a><a href="#14-1-2-%E9%87%8D%E7%BD%AE%E8%A1%A8%E5%8D%95" title="14.1.2 重置表单"></a>14.1.2 重置表单</h4><h4 id="14-1-3-表单字段"><a href="#14-1-3-表单字段" class="headerlink" title="14.1.3 表单字段"></a><a href="#14-1-3-%E8%A1%A8%E5%8D%95%E5%AD%97%E6%AE%B5" title="14.1.3 表单字段"></a>14.1.3 表单字段</h4><h3 id="14-2-文本框脚本"><a href="#14-2-文本框脚本" class="headerlink" title="14.2 文本框脚本"></a><a href="#14-2-%E6%96%87%E6%9C%AC%E6%A1%86%E8%84%9A%E6%9C%AC" title="14.2 文本框脚本"></a>14.2 文本框脚本</h3><h4 id="14-2-1-选择文本"><a href="#14-2-1-选择文本" class="headerlink" title="14.2.1 选择文本"></a><a href="#14-2-1-%E9%80%89%E6%8B%A9%E6%96%87%E6%9C%AC" title="14.2.1 选择文本"></a>14.2.1 选择文本</h4><h4 id="14-2-2-过滤输入"><a href="#14-2-2-过滤输入" class="headerlink" title="14.2.2 过滤输入"></a><a href="#14-2-2-%E8%BF%87%E6%BB%A4%E8%BE%93%E5%85%A5" title="14.2.2 过滤输入"></a>14.2.2 过滤输入</h4><h4 id="14-2-3-自动切换焦点"><a href="#14-2-3-自动切换焦点" class="headerlink" title="14.2.3 自动切换焦点"></a><a href="#14-2-3-%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%84%A6%E7%82%B9" title="14.2.3 自动切换焦点"></a>14.2.3 自动切换焦点</h4><h4 id="14-2-4-HTML5约束验证API"><a href="#14-2-4-HTML5约束验证API" class="headerlink" title="14.2.4 HTML5约束验证API"></a><a href="#14-2-4-HTML5%E7%BA%A6%E6%9D%9F%E9%AA%8C%E8%AF%81API" title="14.2.4 HTML5约束验证API"></a>14.2.4 HTML5约束验证API</h4><h3 id="14-3-选择框脚本"><a href="#14-3-选择框脚本" class="headerlink" title="14.3 选择框脚本"></a><a href="#14-3-%E9%80%89%E6%8B%A9%E6%A1%86%E8%84%9A%E6%9C%AC" title="14.3 选择框脚本"></a>14.3 选择框脚本</h3><h4 id="14-3-1-选择选项"><a href="#14-3-1-选择选项" class="headerlink" title="14.3.1 选择选项"></a><a href="#14-3-1-%E9%80%89%E6%8B%A9%E9%80%89%E9%A1%B9" title="14.3.1 选择选项"></a>14.3.1 选择选项</h4><h4 id="14-3-2-添加选项"><a href="#14-3-2-添加选项" class="headerlink" title="14.3.2 添加选项"></a><a href="#14-3-2-%E6%B7%BB%E5%8A%A0%E9%80%89%E9%A1%B9" title="14.3.2 添加选项"></a>14.3.2 添加选项</h4><h4 id="14-3-3-移除选项"><a href="#14-3-3-移除选项" class="headerlink" title="14.3.3 移除选项"></a><a href="#14-3-3-%E7%A7%BB%E9%99%A4%E9%80%89%E9%A1%B9" title="14.3.3 移除选项"></a>14.3.3 移除选项</h4><h4 id="14-3-4-移动和重排选项"><a href="#14-3-4-移动和重排选项" class="headerlink" title="14.3.4 移动和重排选项"></a><a href="#14-3-4-%E7%A7%BB%E5%8A%A8%E5%92%8C%E9%87%8D%E6%8E%92%E9%80%89%E9%A1%B9" title="14.3.4 移动和重排选项"></a>14.3.4 移动和重排选项</h4><h3 id="14-4-表单序列化"><a href="#14-4-表单序列化" class="headerlink" title="14.4 表单序列化"></a><a href="#14-4-%E8%A1%A8%E5%8D%95%E5%BA%8F%E5%88%97%E5%8C%96" title="14.4 表单序列化"></a>14.4 表单序列化</h3><h3 id="14-5-富文本编辑"><a href="#14-5-富文本编辑" class="headerlink" title="14.5 富文本编辑"></a><a href="#14-5-%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91" title="14.5 富文本编辑"></a>14.5 富文本编辑</h3><h4 id="14-5-1-使用contenteditable属性"><a href="#14-5-1-使用contenteditable属性" class="headerlink" title="14.5.1 使用contenteditable属性"></a><a href="#14-5-1-%E4%BD%BF%E7%94%A8contenteditable%E5%B1%9E%E6%80%A7" title="14.5.1 使用contenteditable属性"></a>14.5.1 使用contenteditable属性</h4><h4 id="14-5-2-操作富文本"><a href="#14-5-2-操作富文本" class="headerlink" title="14.5.2 操作富文本"></a><a href="#14-5-2-%E6%93%8D%E4%BD%9C%E5%AF%8C%E6%96%87%E6%9C%AC" title="14.5.2 操作富文本"></a>14.5.2 操作富文本</h4><h4 id="14-5-3-富文本选区"><a href="#14-5-3-富文本选区" class="headerlink" title="14.5.3 富文本选区"></a><a href="#14-5-3-%E5%AF%8C%E6%96%87%E6%9C%AC%E9%80%89%E5%8C%BA" title="14.5.3 富文本选区"></a>14.5.3 富文本选区</h4><h4 id="14-5-4-表单与富文本"><a href="#14-5-4-表单与富文本" class="headerlink" title="14.5.4 表单与富文本"></a><a href="#14-5-4-%E8%A1%A8%E5%8D%95%E4%B8%8E%E5%AF%8C%E6%96%87%E6%9C%AC" title="14.5.4 表单与富文本"></a>14.5.4 表单与富文本</h4><h3 id="14-6-小结"><a href="#14-6-小结" class="headerlink" title="14.6 小结"></a><a href="#14-6-%E5%B0%8F%E7%BB%93" title="14.6 小结"></a>14.6 小结</h3><h2 id="第十五章-使用Canvas绘图"><a href="#第十五章-使用Canvas绘图" class="headerlink" title="第十五章 使用Canvas绘图"></a><a href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%9B%BE" title="第十五章 使用Canvas绘图"></a>第十五章 使用Canvas绘图</h2><h3 id="15-1-基本用法"><a href="#15-1-基本用法" class="headerlink" title="15.1 基本用法"></a><a href="#15-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" title="15.1 基本用法"></a>15.1 基本用法</h3><h3 id="15-2-2D上下文"><a href="#15-2-2D上下文" class="headerlink" title="15.2 2D上下文"></a><a href="#15-2-2D%E4%B8%8A%E4%B8%8B%E6%96%87" title="15.2 2D上下文"></a>15.2 2D上下文</h3><h4 id="15-2-1-填充和描边"><a href="#15-2-1-填充和描边" class="headerlink" title="15.2.1 填充和描边"></a><a href="#15-2-1-%E5%A1%AB%E5%85%85%E5%92%8C%E6%8F%8F%E8%BE%B9" title="15.2.1 填充和描边"></a>15.2.1 填充和描边</h4><h4 id="15-2-2-绘制矩形"><a href="#15-2-2-绘制矩形" class="headerlink" title="15.2.2 绘制矩形"></a><a href="#15-2-2-%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2" title="15.2.2 绘制矩形"></a>15.2.2 绘制矩形</h4><h4 id="15-2-3-绘制路径"><a href="#15-2-3-绘制路径" class="headerlink" title="15.2.3 绘制路径"></a><a href="#15-2-3-%E7%BB%98%E5%88%B6%E8%B7%AF%E5%BE%84" title="15.2.3 绘制路径"></a>15.2.3 绘制路径</h4><h4 id="15-2-4-绘制文本"><a href="#15-2-4-绘制文本" class="headerlink" title="15.2.4 绘制文本"></a><a href="#15-2-4-%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC" title="15.2.4 绘制文本"></a>15.2.4 绘制文本</h4><h4 id="15-2-5-变换"><a href="#15-2-5-变换" class="headerlink" title="15.2.5 变换"></a><a href="#15-2-5-%E5%8F%98%E6%8D%A2" title="15.2.5 变换"></a>15.2.5 变换</h4><h4 id="15-2-6-绘制图像"><a href="#15-2-6-绘制图像" class="headerlink" title="15.2.6 绘制图像"></a><a href="#15-2-6-%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F" title="15.2.6 绘制图像"></a>15.2.6 绘制图像</h4><h4 id="15-2-7-阴影"><a href="#15-2-7-阴影" class="headerlink" title="15.2.7 阴影"></a><a href="#15-2-7-%E9%98%B4%E5%BD%B1" title="15.2.7 阴影"></a>15.2.7 阴影</h4><h4 id="15-2-8-渐变"><a href="#15-2-8-渐变" class="headerlink" title="15.2.8 渐变"></a><a href="#15-2-8-%E6%B8%90%E5%8F%98" title="15.2.8 渐变"></a>15.2.8 渐变</h4><h4 id="15-2-9-模式"><a href="#15-2-9-模式" class="headerlink" title="15.2.9 模式"></a><a href="#15-2-9-%E6%A8%A1%E5%BC%8F" title="15.2.9 模式"></a>15.2.9 模式</h4><h4 id="15-2-10-使用图像数据"><a href="#15-2-10-使用图像数据" class="headerlink" title="15.2.10 使用图像数据"></a><a href="#15-2-10-%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE" title="15.2.10 使用图像数据"></a>15.2.10 使用图像数据</h4><h4 id="15-2-11-合成"><a href="#15-2-11-合成" class="headerlink" title="15.2.11 合成"></a><a href="#15-2-11-%E5%90%88%E6%88%90" title="15.2.11 合成"></a>15.2.11 合成</h4><h3 id="15-3-WebGL"><a href="#15-3-WebGL" class="headerlink" title="15.3 WebGL"></a><a href="#15-3-WebGL" title="15.3 WebGL"></a>15.3 WebGL</h3><h4 id="15-3-1-类型化数组"><a href="#15-3-1-类型化数组" class="headerlink" title="15.3.1 类型化数组"></a><a href="#15-3-1-%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84" title="15.3.1 类型化数组"></a>15.3.1 类型化数组</h4><h4 id="15-3-2-WebGL上下文"><a href="#15-3-2-WebGL上下文" class="headerlink" title="15.3.2 WebGL上下文"></a><a href="#15-3-2-WebGL%E4%B8%8A%E4%B8%8B%E6%96%87" title="15.3.2 WebGL上下文"></a>15.3.2 WebGL上下文</h4><h4 id="15-3-3-支持"><a href="#15-3-3-支持" class="headerlink" title="15.3.3 支持"></a><a href="#15-3-3-%E6%94%AF%E6%8C%81" title="15.3.3 支持"></a>15.3.3 支持</h4><h3 id="15-4-小结"><a href="#15-4-小结" class="headerlink" title="15.4 小结"></a><a href="#15-4-%E5%B0%8F%E7%BB%93" title="15.4 小结"></a>15.4 小结</h3><h2 id="第十六章-HTML5脚本编程"><a href="#第十六章-HTML5脚本编程" class="headerlink" title="第十六章 HTML5脚本编程"></a><a href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-HTML5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B" title="第十六章 HTML5脚本编程"></a>第十六章 HTML5脚本编程</h2><h3 id="16-1-跨文档消息传递"><a href="#16-1-跨文档消息传递" class="headerlink" title="16.1 跨文档消息传递"></a><a href="#16-1-%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92" title="16.1 跨文档消息传递"></a>16.1 跨文档消息传递</h3><h3 id="16-2-原生拖放"><a href="#16-2-原生拖放" class="headerlink" title="16.2 原生拖放"></a><a href="#16-2-%E5%8E%9F%E7%94%9F%E6%8B%96%E6%94%BE" title="16.2 原生拖放"></a>16.2 原生拖放</h3><h4 id="16-2-1-拖放事件"><a href="#16-2-1-拖放事件" class="headerlink" title="16.2.1 拖放事件"></a><a href="#16-2-1-%E6%8B%96%E6%94%BE%E4%BA%8B%E4%BB%B6" title="16.2.1 拖放事件"></a>16.2.1 拖放事件</h4><h4 id="16-2-2-自定义放置目标"><a href="#16-2-2-自定义放置目标" class="headerlink" title="16.2.2 自定义放置目标"></a><a href="#16-2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%BE%E7%BD%AE%E7%9B%AE%E6%A0%87" title="16.2.2 自定义放置目标"></a>16.2.2 自定义放置目标</h4><h4 id="16-2-3-dataTransfer对象"><a href="#16-2-3-dataTransfer对象" class="headerlink" title="16.2.3 dataTransfer对象"></a><a href="#16-2-3-dataTransfer%E5%AF%B9%E8%B1%A1" title="16.2.3 dataTransfer对象"></a>16.2.3 dataTransfer对象</h4><h4 id="16-2-4-dropEffect与effectAllowed"><a href="#16-2-4-dropEffect与effectAllowed" class="headerlink" title="16.2.4 dropEffect与effectAllowed"></a><a href="#16-2-4-dropEffect%E4%B8%8EeffectAllowed" title="16.2.4 dropEffect与effectAllowed"></a>16.2.4 dropEffect与effectAllowed</h4><h4 id="16-2-4-dropEffect与effectAllowed-1"><a href="#16-2-4-dropEffect与effectAllowed-1" class="headerlink" title="16.2.4 dropEffect与effectAllowed"></a><a href="#16-2-4-dropEffect%E4%B8%8EeffectAllowed-1" title="16.2.4 dropEffect与effectAllowed"></a>16.2.4 dropEffect与effectAllowed</h4><h4 id="16-2-5-可拖动"><a href="#16-2-5-可拖动" class="headerlink" title="16.2.5 可拖动"></a><a href="#16-2-5-%E5%8F%AF%E6%8B%96%E5%8A%A8" title="16.2.5 可拖动"></a>16.2.5 可拖动</h4><h4 id="16-2-6-其他成员"><a href="#16-2-6-其他成员" class="headerlink" title="16.2.6 其他成员"></a><a href="#16-2-6-%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98" title="16.2.6 其他成员"></a>16.2.6 其他成员</h4><h3 id="16-3-媒体元素"><a href="#16-3-媒体元素" class="headerlink" title="16.3 媒体元素"></a><a href="#16-3-%E5%AA%92%E4%BD%93%E5%85%83%E7%B4%A0" title="16.3 媒体元素"></a>16.3 媒体元素</h3><h4 id="16-3-1-属性"><a href="#16-3-1-属性" class="headerlink" title="16.3.1 属性"></a><a href="#16-3-1-%E5%B1%9E%E6%80%A7" title="16.3.1 属性"></a>16.3.1 属性</h4><h4 id="16-3-2-事件"><a href="#16-3-2-事件" class="headerlink" title="16.3.2 事件"></a><a href="#16-3-2-%E4%BA%8B%E4%BB%B6" title="16.3.2 事件"></a>16.3.2 事件</h4><h4 id="16-3-3-自定义媒体播放器"><a href="#16-3-3-自定义媒体播放器" class="headerlink" title="16.3.3 自定义媒体播放器"></a><a href="#16-3-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AA%92%E4%BD%93%E6%92%AD%E6%94%BE%E5%99%A8" title="16.3.3 自定义媒体播放器"></a>16.3.3 自定义媒体播放器</h4><h4 id="16-3-4-检测编解码器的支持情况"><a href="#16-3-4-检测编解码器的支持情况" class="headerlink" title="16.3.4 检测编解码器的支持情况"></a><a href="#16-3-4-%E6%A3%80%E6%B5%8B%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5" title="16.3.4 检测编解码器的支持情况"></a>16.3.4 检测编解码器的支持情况</h4><h4 id="16-3-5-Audio类型"><a href="#16-3-5-Audio类型" class="headerlink" title="16.3.5 Audio类型"></a><a href="#16-3-5-Audio%E7%B1%BB%E5%9E%8B" title="16.3.5 Audio类型"></a>16.3.5 Audio类型</h4><h3 id="16-4-历史状态管理"><a href="#16-4-历史状态管理" class="headerlink" title="16.4 历史状态管理"></a><a href="#16-4-%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" title="16.4 历史状态管理"></a>16.4 历史状态管理</h3><h3 id="16-5-小结"><a href="#16-5-小结" class="headerlink" title="16.5 小结"></a><a href="#16-5-%E5%B0%8F%E7%BB%93" title="16.5 小结"></a>16.5 小结</h3><h2 id="第十七章-错误处理与调试"><a href="#第十七章-错误处理与调试" class="headerlink" title="第十七章 错误处理与调试"></a><a href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95" title="第十七章 错误处理与调试"></a>第十七章 错误处理与调试</h2><h3 id="17-1-浏览器报告的错误"><a href="#17-1-浏览器报告的错误" class="headerlink" title="17.1 浏览器报告的错误"></a><a href="#17-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8A%A5%E5%91%8A%E7%9A%84%E9%94%99%E8%AF%AF" title="17.1 浏览器报告的错误"></a>17.1 浏览器报告的错误</h3><h4 id="17-1-1-IE"><a href="#17-1-1-IE" class="headerlink" title="17.1.1 IE"></a><a href="#17-1-1-IE" title="17.1.1 IE"></a>17.1.1 IE</h4><h4 id="17-1-2-Firefox"><a href="#17-1-2-Firefox" class="headerlink" title="17.1.2 Firefox"></a><a href="#17-1-2-Firefox" title="17.1.2 Firefox"></a>17.1.2 Firefox</h4><h4 id="17-1-3-Safari"><a href="#17-1-3-Safari" class="headerlink" title="17.1.3 Safari"></a><a href="#17-1-3-Safari" title="17.1.3 Safari"></a>17.1.3 Safari</h4><h4 id="17-1-4-Opera"><a href="#17-1-4-Opera" class="headerlink" title="17.1.4 Opera"></a><a href="#17-1-4-Opera" title="17.1.4 Opera"></a>17.1.4 Opera</h4><h4 id="17-1-5-Chrome"><a href="#17-1-5-Chrome" class="headerlink" title="17.1.5 Chrome"></a><a href="#17-1-5-Chrome" title="17.1.5 Chrome"></a>17.1.5 Chrome</h4><h3 id="17-2-错误处理"><a href="#17-2-错误处理" class="headerlink" title="17.2 错误处理"></a><a href="#17-2-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" title="17.2 错误处理"></a>17.2 错误处理</h3><h4 id="17-2-1-try-catch语句"><a href="#17-2-1-try-catch语句" class="headerlink" title="17.2.1 try-catch语句"></a><a href="#17-2-1-try-catch%E8%AF%AD%E5%8F%A5" title="17.2.1 try-catch语句"></a>17.2.1 try-catch语句</h4><h4 id="17-2-2-抛出错误"><a href="#17-2-2-抛出错误" class="headerlink" title="17.2.2 抛出错误"></a><a href="#17-2-2-%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF" title="17.2.2 抛出错误"></a>17.2.2 抛出错误</h4><h4 id="17-2-3-错误（error）事件"><a href="#17-2-3-错误（error）事件" class="headerlink" title="17.2.3 错误（error）事件"></a><a href="#17-2-3-%E9%94%99%E8%AF%AF%EF%BC%88error%EF%BC%89%E4%BA%8B%E4%BB%B6" title="17.2.3 错误（error）事件"></a>17.2.3 错误（error）事件</h4><h4 id="17-2-4-处理错误的策略"><a href="#17-2-4-处理错误的策略" class="headerlink" title="17.2.4 处理错误的策略"></a><a href="#17-2-4-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E7%AD%96%E7%95%A5" title="17.2.4 处理错误的策略"></a>17.2.4 处理错误的策略</h4><h4 id="17-2-5-常见的错误类型"><a href="#17-2-5-常见的错误类型" class="headerlink" title="17.2.5 常见的错误类型"></a><a href="#17-2-5-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B" title="17.2.5 常见的错误类型"></a>17.2.5 常见的错误类型</h4><h4 id="17-2-6-区分致命错误和非致命错误"><a href="#17-2-6-区分致命错误和非致命错误" class="headerlink" title="17.2.6 区分致命错误和非致命错误"></a><a href="#17-2-6-%E5%8C%BA%E5%88%86%E8%87%B4%E5%91%BD%E9%94%99%E8%AF%AF%E5%92%8C%E9%9D%9E%E8%87%B4%E5%91%BD%E9%94%99%E8%AF%AF" title="17.2.6 区分致命错误和非致命错误"></a>17.2.6 区分致命错误和非致命错误</h4><h4 id="17-2-7-把错误记录到服务器"><a href="#17-2-7-把错误记录到服务器" class="headerlink" title="17.2.7 把错误记录到服务器"></a><a href="#17-2-7-%E6%8A%8A%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8" title="17.2.7 把错误记录到服务器"></a>17.2.7 把错误记录到服务器</h4><h3 id="17-3-调试技术"><a href="#17-3-调试技术" class="headerlink" title="17.3 调试技术"></a><a href="#17-3-%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF" title="17.3 调试技术"></a>17.3 调试技术</h3><h4 id="17-3-1-将消息记录到控制台"><a href="#17-3-1-将消息记录到控制台" class="headerlink" title="17.3.1 将消息记录到控制台"></a><a href="#17-3-1-%E5%B0%86%E6%B6%88%E6%81%AF%E8%AE%B0%E5%BD%95%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0" title="17.3.1 将消息记录到控制台"></a>17.3.1 将消息记录到控制台</h4><h4 id="17-3-2-将消息记录到当前页面"><a href="#17-3-2-将消息记录到当前页面" class="headerlink" title="17.3.2 将消息记录到当前页面"></a><a href="#17-3-2-%E5%B0%86%E6%B6%88%E6%81%AF%E8%AE%B0%E5%BD%95%E5%88%B0%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2" title="17.3.2 将消息记录到当前页面"></a>17.3.2 将消息记录到当前页面</h4><h4 id="17-3-3-抛出错误"><a href="#17-3-3-抛出错误" class="headerlink" title="17.3.3 抛出错误"></a><a href="#17-3-3-%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF" title="17.3.3 抛出错误"></a>17.3.3 抛出错误</h4><h3 id="17-4-常见的IE错误"><a href="#17-4-常见的IE错误" class="headerlink" title="17.4 常见的IE错误"></a><a href="#17-4-%E5%B8%B8%E8%A7%81%E7%9A%84IE%E9%94%99%E8%AF%AF" title="17.4 常见的IE错误"></a>17.4 常见的IE错误</h3><h4 id="17-4-1-操作终止"><a href="#17-4-1-操作终止" class="headerlink" title="17.4.1 操作终止"></a><a href="#17-4-1-%E6%93%8D%E4%BD%9C%E7%BB%88%E6%AD%A2" title="17.4.1 操作终止"></a>17.4.1 操作终止</h4><h4 id="17-4-2-无效字符"><a href="#17-4-2-无效字符" class="headerlink" title="17.4.2 无效字符"></a><a href="#17-4-2-%E6%97%A0%E6%95%88%E5%AD%97%E7%AC%A6" title="17.4.2 无效字符"></a>17.4.2 无效字符</h4><h4 id="17-4-3-未找到成员"><a href="#17-4-3-未找到成员" class="headerlink" title="17.4.3 未找到成员"></a><a href="#17-4-3-%E6%9C%AA%E6%89%BE%E5%88%B0%E6%88%90%E5%91%98" title="17.4.3 未找到成员"></a>17.4.3 未找到成员</h4><h4 id="17-4-4-未知运行时错误"><a href="#17-4-4-未知运行时错误" class="headerlink" title="17.4.4 未知运行时错误"></a><a href="#17-4-4-%E6%9C%AA%E7%9F%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF" title="17.4.4 未知运行时错误"></a>17.4.4 未知运行时错误</h4><h4 id="17-4-5-语法错误"><a href="#17-4-5-语法错误" class="headerlink" title="17.4.5 语法错误"></a><a href="#17-4-5-%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF" title="17.4.5 语法错误"></a>17.4.5 语法错误</h4><h4 id="17-4-6-系统无法找到指定资源"><a href="#17-4-6-系统无法找到指定资源" class="headerlink" title="17.4.6 系统无法找到指定资源"></a><a href="#17-4-6-%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E8%B5%84%E6%BA%90" title="17.4.6 系统无法找到指定资源"></a>17.4.6 系统无法找到指定资源</h4><h3 id="17-5-小结"><a href="#17-5-小结" class="headerlink" title="17.5 小结"></a><a href="#17-5-%E5%B0%8F%E7%BB%93" title="17.5 小结"></a>17.5 小结</h3><h2 id="第十八章-JavaScript与XML"><a href="#第十八章-JavaScript与XML" class="headerlink" title="第十八章 JavaScript与XML"></a><a href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-JavaScript%E4%B8%8EXML" title="第十八章 JavaScript与XML"></a>第十八章 JavaScript与XML</h2><h3 id="18-1-浏览器对XML-DOM的支持"><a href="#18-1-浏览器对XML-DOM的支持" class="headerlink" title="18.1 浏览器对XML DOM的支持"></a><a href="#18-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9XML-DOM%E7%9A%84%E6%94%AF%E6%8C%81" title="18.1 浏览器对XML DOM的支持"></a>18.1 浏览器对XML DOM的支持</h3><h4 id="18-1-1-DOM2级核心"><a href="#18-1-1-DOM2级核心" class="headerlink" title="18.1.1 DOM2级核心"></a><a href="#18-1-1-DOM2%E7%BA%A7%E6%A0%B8%E5%BF%83" title="18.1.1 DOM2级核心"></a>18.1.1 DOM2级核心</h4><h4 id="18-1-2-DOMParser类型"><a href="#18-1-2-DOMParser类型" class="headerlink" title="18.1.2 DOMParser类型"></a><a href="#18-1-2-DOMParser%E7%B1%BB%E5%9E%8B" title="18.1.2 DOMParser类型"></a>18.1.2 DOMParser类型</h4><h4 id="18-1-3-XMLSerializer类型"><a href="#18-1-3-XMLSerializer类型" class="headerlink" title="18.1.3 XMLSerializer类型"></a><a href="#18-1-3-XMLSerializer%E7%B1%BB%E5%9E%8B" title="18.1.3 XMLSerializer类型"></a>18.1.3 XMLSerializer类型</h4><h4 id="18-1-4-IE8及之前版本中的XML"><a href="#18-1-4-IE8及之前版本中的XML" class="headerlink" title="18.1.4 IE8及之前版本中的XML"></a><a href="#18-1-4-IE8%E5%8F%8A%E4%B9%8B%E5%89%8D%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84XML" title="18.1.4 IE8及之前版本中的XML"></a>18.1.4 IE8及之前版本中的XML</h4><h4 id="18-1-5-跨浏览器处理XML"><a href="#18-1-5-跨浏览器处理XML" class="headerlink" title="18.1.5 跨浏览器处理XML"></a><a href="#18-1-5-%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%84%E7%90%86XML" title="18.1.5 跨浏览器处理XML"></a>18.1.5 跨浏览器处理XML</h4><h3 id="18-2-浏览器对XPath的支持"><a href="#18-2-浏览器对XPath的支持" class="headerlink" title="18.2 浏览器对XPath的支持"></a><a href="#18-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9XPath%E7%9A%84%E6%94%AF%E6%8C%81" title="18.2 浏览器对XPath的支持"></a>18.2 浏览器对XPath的支持</h3><h4 id="18-2-1-DOM3级XPath"><a href="#18-2-1-DOM3级XPath" class="headerlink" title="18.2.1 DOM3级XPath"></a><a href="#18-2-1-DOM3%E7%BA%A7XPath" title="18.2.1 DOM3级XPath"></a>18.2.1 DOM3级XPath</h4><h4 id="18-2-2-IE中的XPath"><a href="#18-2-2-IE中的XPath" class="headerlink" title="18.2.2 IE中的XPath"></a><a href="#18-2-2-IE%E4%B8%AD%E7%9A%84XPath" title="18.2.2 IE中的XPath"></a>18.2.2 IE中的XPath</h4><h4 id="18-2-3-跨浏览器使用XPath"><a href="#18-2-3-跨浏览器使用XPath" class="headerlink" title="18.2.3 跨浏览器使用XPath"></a><a href="#18-2-3-%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8XPath" title="18.2.3 跨浏览器使用XPath"></a>18.2.3 跨浏览器使用XPath</h4><h3 id="18-3-浏览器对XSLT的支持"><a href="#18-3-浏览器对XSLT的支持" class="headerlink" title="18.3 浏览器对XSLT的支持"></a><a href="#18-3-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9XSLT%E7%9A%84%E6%94%AF%E6%8C%81" title="18.3 浏览器对XSLT的支持"></a>18.3 浏览器对XSLT的支持</h3><h4 id="18-3-1-IE中的XSLT"><a href="#18-3-1-IE中的XSLT" class="headerlink" title="18.3.1 IE中的XSLT"></a><a href="#18-3-1-IE%E4%B8%AD%E7%9A%84XSLT" title="18.3.1 IE中的XSLT"></a>18.3.1 IE中的XSLT</h4><h4 id="18-3-2-XSLT中Processor类型"><a href="#18-3-2-XSLT中Processor类型" class="headerlink" title="18.3.2 XSLT中Processor类型"></a><a href="#18-3-2-XSLT%E4%B8%ADProcessor%E7%B1%BB%E5%9E%8B" title="18.3.2 XSLT中Processor类型"></a>18.3.2 XSLT中Processor类型</h4><h4 id="18-3-3-跨浏览器使用XSLT"><a href="#18-3-3-跨浏览器使用XSLT" class="headerlink" title="18.3.3 跨浏览器使用XSLT"></a><a href="#18-3-3-%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8XSLT" title="18.3.3 跨浏览器使用XSLT"></a>18.3.3 跨浏览器使用XSLT</h4><h3 id="18-4-小结"><a href="#18-4-小结" class="headerlink" title="18.4 小结"></a><a href="#18-4-%E5%B0%8F%E7%BB%93" title="18.4 小结"></a>18.4 小结</h3>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级程序设计2</title>
      <link href="/posts/JavaScript2.html"/>
      <url>/posts/JavaScript2.html</url>
      
        <content type="html"><![CDATA[<h2 id="第十九章-E4X"><a href="#第十九章-E4X" class="headerlink" title="第十九章 E4X"></a>第十九章 E4X</h2><h3 id="19-1-E4X的类型"><a href="#19-1-E4X的类型" class="headerlink" title="19.1 E4X的类型"></a>19.1 E4X的类型</h3><h4 id="19-1-1-XML类型"><a href="#19-1-1-XML类型" class="headerlink" title="19.1.1 XML类型"></a>19.1.1 XML类型</h4><h4 id="19-1-2-XMLList类型"><a href="#19-1-2-XMLList类型" class="headerlink" title="19.1.2 XMLList类型"></a>19.1.2 XMLList类型</h4><h4 id="19-1-3-Namespace类型"><a href="#19-1-3-Namespace类型" class="headerlink" title="19.1.3 Namespace类型"></a>19.1.3 Namespace类型</h4><h4 id="19-1-4-QName类型"><a href="#19-1-4-QName类型" class="headerlink" title="19.1.4 QName类型"></a>19.1.4 QName类型</h4><h3 id="19-2-一般用法"><a href="#19-2-一般用法" class="headerlink" title="19.2 一般用法"></a>19.2 一般用法</h3><h4 id="19-2-1-访问特性"><a href="#19-2-1-访问特性" class="headerlink" title="19.2.1 访问特性"></a>19.2.1 访问特性</h4><h4 id="19-2-2-其他类型节点"><a href="#19-2-2-其他类型节点" class="headerlink" title="19.2.2 其他类型节点"></a>19.2.2 其他类型节点</h4><h4 id="19-2-3-查询"><a href="#19-2-3-查询" class="headerlink" title="19.2.3 查询"></a>19.2.3 查询</h4><h4 id="19-2-4-构建和操作XML"><a href="#19-2-4-构建和操作XML" class="headerlink" title="19.2.4 构建和操作XML"></a>19.2.4 构建和操作XML</h4><h4 id="19-2-5-解析和序列化"><a href="#19-2-5-解析和序列化" class="headerlink" title="19.2.5 解析和序列化"></a>19.2.5 解析和序列化</h4><h4 id="19-2-6-命名空间"><a href="#19-2-6-命名空间" class="headerlink" title="19.2.6 命名空间"></a>19.2.6 命名空间</h4><h3 id="19-3-其他变化"><a href="#19-3-其他变化" class="headerlink" title="19.3 其他变化"></a>19.3 其他变化</h3><h3 id="19-4-全面启用E4X"><a href="#19-4-全面启用E4X" class="headerlink" title="19.4 全面启用E4X"></a>19.4 全面启用E4X</h3><h3 id="19-5-小结"><a href="#19-5-小结" class="headerlink" title="19.5 小结"></a>19.5 小结</h3><h2 id="第二十章-JSON"><a href="#第二十章-JSON" class="headerlink" title="第二十章 JSON"></a>第二十章 JSON</h2><h3 id="20-1-语法"><a href="#20-1-语法" class="headerlink" title="20.1 语法"></a>20.1 语法</h3><h4 id="20-1-1-简单值"><a href="#20-1-1-简单值" class="headerlink" title="20.1.1 简单值"></a>20.1.1 简单值</h4><h4 id="20-1-2-对象"><a href="#20-1-2-对象" class="headerlink" title="20.1.2 对象"></a>20.1.2 对象</h4><h4 id="20-1-3-数组"><a href="#20-1-3-数组" class="headerlink" title="20.1.3 数组"></a>20.1.3 数组</h4><h3 id="20-2-解析和序列化"><a href="#20-2-解析和序列化" class="headerlink" title="20.2 解析和序列化"></a>20.2 解析和序列化</h3><h4 id="20-2-1-JSON对象"><a href="#20-2-1-JSON对象" class="headerlink" title="20.2.1 JSON对象"></a>20.2.1 JSON对象</h4><h4 id="20-2-2-序列化选项"><a href="#20-2-2-序列化选项" class="headerlink" title="20.2.2 序列化选项"></a>20.2.2 序列化选项</h4><h4 id="20-2-3-解析选项"><a href="#20-2-3-解析选项" class="headerlink" title="20.2.3 解析选项"></a>20.2.3 解析选项</h4><h3 id="20-3-小结"><a href="#20-3-小结" class="headerlink" title="20.3 小结"></a>20.3 小结</h3><h2 id="第二十一章-Ajax与Comet"><a href="#第二十一章-Ajax与Comet" class="headerlink" title="第二十一章 Ajax与Comet"></a>第二十一章 Ajax与Comet</h2><h3 id="21-1-XMLHttpRequest对象"><a href="#21-1-XMLHttpRequest对象" class="headerlink" title="21.1 XMLHttpRequest对象"></a>21.1 XMLHttpRequest对象</h3><h4 id="21-1-1-XHR的用法"><a href="#21-1-1-XHR的用法" class="headerlink" title="21.1.1 XHR的用法"></a>21.1.1 XHR的用法</h4><h4 id="21-1-2-HTTP头部信息"><a href="#21-1-2-HTTP头部信息" class="headerlink" title="21.1.2 HTTP头部信息"></a>21.1.2 HTTP头部信息</h4><h4 id="21-1-3-GET请求"><a href="#21-1-3-GET请求" class="headerlink" title="21.1.3 GET请求"></a>21.1.3 GET请求</h4><h4 id="21-1-4-POST请求"><a href="#21-1-4-POST请求" class="headerlink" title="21.1.4 POST请求"></a>21.1.4 POST请求</h4><h3 id="21-2-XMLHttpRequest-2级"><a href="#21-2-XMLHttpRequest-2级" class="headerlink" title="21.2 XMLHttpRequest 2级"></a>21.2 XMLHttpRequest 2级</h3><h4 id="21-2-1-FormData"><a href="#21-2-1-FormData" class="headerlink" title="21.2.1 FormData"></a>21.2.1 FormData</h4><h4 id="21-2-2-超时设定"><a href="#21-2-2-超时设定" class="headerlink" title="21.2.2 超时设定"></a>21.2.2 超时设定</h4><h4 id="21-2-3-overrideMimeType-方法"><a href="#21-2-3-overrideMimeType-方法" class="headerlink" title="21.2.3 overrideMimeType()方法"></a>21.2.3 overrideMimeType()方法</h4><h3 id="21-3-进度事件"><a href="#21-3-进度事件" class="headerlink" title="21.3 进度事件"></a>21.3 进度事件</h3><h4 id="21-3-1-load事件"><a href="#21-3-1-load事件" class="headerlink" title="21.3.1 load事件"></a>21.3.1 load事件</h4><h4 id="21-3-2-progress事件"><a href="#21-3-2-progress事件" class="headerlink" title="21.3.2 progress事件"></a>21.3.2 progress事件</h4><h3 id="21-4-跨源资源共享"><a href="#21-4-跨源资源共享" class="headerlink" title="21.4 跨源资源共享"></a>21.4 跨源资源共享</h3><h4 id="21-4-1-IE对CORS的实现"><a href="#21-4-1-IE对CORS的实现" class="headerlink" title="21.4.1 IE对CORS的实现"></a>21.4.1 IE对CORS的实现</h4><h4 id="21-4-2-其他浏览器对CORS的实现"><a href="#21-4-2-其他浏览器对CORS的实现" class="headerlink" title="21.4.2 其他浏览器对CORS的实现"></a>21.4.2 其他浏览器对CORS的实现</h4><h4 id="21-4-3-Preflighted-Request"><a href="#21-4-3-Preflighted-Request" class="headerlink" title="21.4.3 Preflighted Request"></a>21.4.3 Preflighted Request</h4><h4 id="21-4-4-带凭据的请求"><a href="#21-4-4-带凭据的请求" class="headerlink" title="21.4.4 带凭据的请求"></a>21.4.4 带凭据的请求</h4><h4 id="21-4-5-跨浏览器的CORS"><a href="#21-4-5-跨浏览器的CORS" class="headerlink" title="21.4.5 跨浏览器的CORS"></a>21.4.5 跨浏览器的CORS</h4><h3 id="21-5-其他跨域技术"><a href="#21-5-其他跨域技术" class="headerlink" title="21.5 其他跨域技术"></a>21.5 其他跨域技术</h3><h4 id="21-5-1-图像Ping"><a href="#21-5-1-图像Ping" class="headerlink" title="21.5.1 图像Ping"></a>21.5.1 图像Ping</h4><h4 id="21-5-2-JSONP"><a href="#21-5-2-JSONP" class="headerlink" title="21.5.2 JSONP"></a>21.5.2 JSONP</h4><h4 id="21-5-3-Comet"><a href="#21-5-3-Comet" class="headerlink" title="21.5.3 Comet"></a>21.5.3 Comet</h4><h4 id="21-5-4-服务器发送事件"><a href="#21-5-4-服务器发送事件" class="headerlink" title="21.5.4 服务器发送事件"></a>21.5.4 服务器发送事件</h4><h4 id="21-5-5-Web-Sockets"><a href="#21-5-5-Web-Sockets" class="headerlink" title="21.5.5 Web Sockets"></a>21.5.5 Web Sockets</h4><h4 id="21-5-6-SSE与Web-Sockets"><a href="#21-5-6-SSE与Web-Sockets" class="headerlink" title="21.5.6 SSE与Web Sockets"></a>21.5.6 SSE与Web Sockets</h4><h3 id="21-6-安全"><a href="#21-6-安全" class="headerlink" title="21.6 安全"></a>21.6 安全</h3><h3 id="21-7-小结"><a href="#21-7-小结" class="headerlink" title="21.7 小结"></a>21.7 小结</h3><h2 id="第二十二章-高级技巧"><a href="#第二十二章-高级技巧" class="headerlink" title="第二十二章 高级技巧"></a>第二十二章 高级技巧</h2><h3 id="22-1-高级函数"><a href="#22-1-高级函数" class="headerlink" title="22.1 高级函数"></a>22.1 高级函数</h3><h4 id="22-1-1-安全的类型检测"><a href="#22-1-1-安全的类型检测" class="headerlink" title="22.1.1 安全的类型检测"></a>22.1.1 安全的类型检测</h4><h4 id="22-1-2-作用域安全的构造函数"><a href="#22-1-2-作用域安全的构造函数" class="headerlink" title="22.1.2 作用域安全的构造函数"></a>22.1.2 作用域安全的构造函数</h4><h4 id="22-1-3-惰性载入函数"><a href="#22-1-3-惰性载入函数" class="headerlink" title="22.1.3 惰性载入函数"></a>22.1.3 惰性载入函数</h4><h4 id="22-1-4-函数绑定"><a href="#22-1-4-函数绑定" class="headerlink" title="22.1.4 函数绑定"></a>22.1.4 函数绑定</h4><h4 id="22-1-5-函数柯里化"><a href="#22-1-5-函数柯里化" class="headerlink" title="22.1.5 函数柯里化"></a>22.1.5 函数柯里化</h4><h3 id="22-2-防篡改对象"><a href="#22-2-防篡改对象" class="headerlink" title="22.2 防篡改对象"></a>22.2 防篡改对象</h3><h4 id="22-2-1-不可扩展对象"><a href="#22-2-1-不可扩展对象" class="headerlink" title="22.2.1 不可扩展对象"></a>22.2.1 不可扩展对象</h4><h4 id="22-2-2-密封的对象"><a href="#22-2-2-密封的对象" class="headerlink" title="22.2.2 密封的对象"></a>22.2.2 密封的对象</h4><h4 id="22-2-3-冻结的对象"><a href="#22-2-3-冻结的对象" class="headerlink" title="22.2.3 冻结的对象"></a>22.2.3 冻结的对象</h4><h3 id="22-3-高级定时器"><a href="#22-3-高级定时器" class="headerlink" title="22.3 高级定时器"></a>22.3 高级定时器</h3><h4 id="22-3-1-重复的定时器"><a href="#22-3-1-重复的定时器" class="headerlink" title="22.3.1 重复的定时器"></a>22.3.1 重复的定时器</h4><h4 id="22-3-2-Yielding-Processes"><a href="#22-3-2-Yielding-Processes" class="headerlink" title="22.3.2 Yielding Processes"></a>22.3.2 Yielding Processes</h4><h4 id="22-3-3-函数节流"><a href="#22-3-3-函数节流" class="headerlink" title="22.3.3 函数节流"></a>22.3.3 函数节流</h4><h3 id="22-4-自定义事件"><a href="#22-4-自定义事件" class="headerlink" title="22.4 自定义事件"></a>22.4 自定义事件</h3><h3 id="22-5-拖放"><a href="#22-5-拖放" class="headerlink" title="22.5 拖放"></a>22.5 拖放</h3><h4 id="22-5-1-修缮拖动功能"><a href="#22-5-1-修缮拖动功能" class="headerlink" title="22.5.1 修缮拖动功能"></a>22.5.1 修缮拖动功能</h4><h4 id="22-5-2-添加自定义事件"><a href="#22-5-2-添加自定义事件" class="headerlink" title="22.5.2 添加自定义事件"></a>22.5.2 添加自定义事件</h4><h3 id="22-6-小结"><a href="#22-6-小结" class="headerlink" title="22.6 小结"></a>22.6 小结</h3><h2 id="第二十三章-离线应用与客户端存储"><a href="#第二十三章-离线应用与客户端存储" class="headerlink" title="第二十三章 离线应用与客户端存储"></a>第二十三章 离线应用与客户端存储</h2><h3 id="23-1-离线检测"><a href="#23-1-离线检测" class="headerlink" title="23.1 离线检测"></a>23.1 离线检测</h3><h3 id="23-2-应用缓存"><a href="#23-2-应用缓存" class="headerlink" title="23.2 应用缓存"></a>23.2 应用缓存</h3><h3 id="23-3-数据存储"><a href="#23-3-数据存储" class="headerlink" title="23.3 数据存储"></a>23.3 数据存储</h3><h4 id="23-3-1-Cookie"><a href="#23-3-1-Cookie" class="headerlink" title="23.3.1 Cookie"></a>23.3.1 Cookie</h4><h4 id="23-3-2-IE用户数据"><a href="#23-3-2-IE用户数据" class="headerlink" title="23.3.2 IE用户数据"></a>23.3.2 IE用户数据</h4><h4 id="23-3-3-Web存储机制"><a href="#23-3-3-Web存储机制" class="headerlink" title="23.3.3 Web存储机制"></a>23.3.3 Web存储机制</h4><h4 id="23-3-4-IndexDB"><a href="#23-3-4-IndexDB" class="headerlink" title="23.3.4 IndexDB"></a>23.3.4 IndexDB</h4><h3 id="23-4-小结"><a href="#23-4-小结" class="headerlink" title="23.4 小结"></a>23.4 小结</h3><h2 id="第二十四章-最佳实践"><a href="#第二十四章-最佳实践" class="headerlink" title="第二十四章 最佳实践"></a>第二十四章 最佳实践</h2><h3 id="24-1-可维护性"><a href="#24-1-可维护性" class="headerlink" title="24.1 可维护性"></a>24.1 可维护性</h3><h4 id="24-1-1-什么是可维护的代码"><a href="#24-1-1-什么是可维护的代码" class="headerlink" title="24.1.1 什么是可维护的代码"></a>24.1.1 什么是可维护的代码</h4><h4 id="24-1-2-代码约定"><a href="#24-1-2-代码约定" class="headerlink" title="24.1.2 代码约定"></a>24.1.2 代码约定</h4><h4 id="24-1-3-松散耦合"><a href="#24-1-3-松散耦合" class="headerlink" title="24.1.3 松散耦合"></a>24.1.3 松散耦合</h4><h4 id="24-1-4-编程实践"><a href="#24-1-4-编程实践" class="headerlink" title="24.1.4 编程实践"></a>24.1.4 编程实践</h4><h3 id="24-2-性能"><a href="#24-2-性能" class="headerlink" title="24.2 性能"></a>24.2 性能</h3><h4 id="24-2-1-注意作用域"><a href="#24-2-1-注意作用域" class="headerlink" title="24.2.1 注意作用域"></a>24.2.1 注意作用域</h4><h4 id="24-2-2-选择正确方法"><a href="#24-2-2-选择正确方法" class="headerlink" title="24.2.2 选择正确方法"></a>24.2.2 选择正确方法</h4><h4 id="24-2-3-最小化语句数"><a href="#24-2-3-最小化语句数" class="headerlink" title="24.2.3 最小化语句数"></a>24.2.3 最小化语句数</h4><h4 id="24-2-4-优化DOM交互"><a href="#24-2-4-优化DOM交互" class="headerlink" title="24.2.4 优化DOM交互"></a>24.2.4 优化DOM交互</h4><h3 id="24-3-部署"><a href="#24-3-部署" class="headerlink" title="24.3 部署"></a>24.3 部署</h3><h4 id="24-3-1-构建过程"><a href="#24-3-1-构建过程" class="headerlink" title="24.3.1 构建过程"></a>24.3.1 构建过程</h4><h4 id="24-3-2-验证"><a href="#24-3-2-验证" class="headerlink" title="24.3.2 验证"></a>24.3.2 验证</h4><h4 id="24-3-3-压缩"><a href="#24-3-3-压缩" class="headerlink" title="24.3.3 压缩"></a>24.3.3 压缩</h4><h3 id="24-4-小结"><a href="#24-4-小结" class="headerlink" title="24.4 小结"></a>24.4 小结</h3><h2 id="第二十五章-新兴的API"><a href="#第二十五章-新兴的API" class="headerlink" title="第二十五章 新兴的API"></a>第二十五章 新兴的API</h2><h3 id="25-1-requestAnimationFrame"><a href="#25-1-requestAnimationFrame" class="headerlink" title="25.1 requestAnimationFrame()"></a>25.1 requestAnimationFrame()</h3><h4 id="25-1-1-早期动画循环"><a href="#25-1-1-早期动画循环" class="headerlink" title="25.1.1 早期动画循环"></a>25.1.1 早期动画循环</h4><h4 id="25-1-2-循环间隔的问题"><a href="#25-1-2-循环间隔的问题" class="headerlink" title="25.1.2 循环间隔的问题"></a>25.1.2 循环间隔的问题</h4><h4 id="25-1-3-mozRequestAnimationFrame"><a href="#25-1-3-mozRequestAnimationFrame" class="headerlink" title="25.1.3 mozRequestAnimationFrame"></a>25.1.3 mozRequestAnimationFrame</h4><h4 id="25-1-4-webkitReqiuestAnimationFreame-与-msRequestAnimationFrame"><a href="#25-1-4-webkitReqiuestAnimationFreame-与-msRequestAnimationFrame" class="headerlink" title="25.1.4 webkitReqiuestAnimationFreame 与 msRequestAnimationFrame"></a>25.1.4 webkitReqiuestAnimationFreame 与 msRequestAnimationFrame</h4><h3 id="25-2-Page-Visibility-API"><a href="#25-2-Page-Visibility-API" class="headerlink" title="25.2 Page Visibility API"></a>25.2 Page Visibility API</h3><h3 id="25-3-Geolocation-API"><a href="#25-3-Geolocation-API" class="headerlink" title="25.3 Geolocation API"></a>25.3 Geolocation API</h3><h3 id="25-4-File-API"><a href="#25-4-File-API" class="headerlink" title="25.4 File API"></a>25.4 File API</h3><h4 id="25-4-1-FileReader类型"><a href="#25-4-1-FileReader类型" class="headerlink" title="25.4.1 FileReader类型"></a>25.4.1 FileReader类型</h4><h4 id="25-4-2-读取部分内容"><a href="#25-4-2-读取部分内容" class="headerlink" title="25.4.2 读取部分内容"></a>25.4.2 读取部分内容</h4><h4 id="25-4-3-对象URL"><a href="#25-4-3-对象URL" class="headerlink" title="25.4.3 对象URL"></a>25.4.3 对象URL</h4><h4 id="25-4-4-读取拖放的文件"><a href="#25-4-4-读取拖放的文件" class="headerlink" title="25.4.4 读取拖放的文件"></a>25.4.4 读取拖放的文件</h4><h4 id="25-4-5-使用XHR上传文件"><a href="#25-4-5-使用XHR上传文件" class="headerlink" title="25.4.5 使用XHR上传文件"></a>25.4.5 使用XHR上传文件</h4><h3 id="25-5-Web计时"><a href="#25-5-Web计时" class="headerlink" title="25.5 Web计时"></a>25.5 Web计时</h3><h3 id="25-6-Web-Workers"><a href="#25-6-Web-Workers" class="headerlink" title="25.6 Web Workers"></a>25.6 Web Workers</h3><h4 id="25-6-1-使用Worker"><a href="#25-6-1-使用Worker" class="headerlink" title="25.6.1 使用Worker"></a>25.6.1 使用Worker</h4><h4 id="25-6-2-Worker全部作用域"><a href="#25-6-2-Worker全部作用域" class="headerlink" title="25.6.2 Worker全部作用域"></a>25.6.2 Worker全部作用域</h4><h4 id="25-6-3-包含其他脚本"><a href="#25-6-3-包含其他脚本" class="headerlink" title="25.6.3 包含其他脚本"></a>25.6.3 包含其他脚本</h4><h4 id="25-6-4-Web-Workers的未来"><a href="#25-6-4-Web-Workers的未来" class="headerlink" title="25.6.4 Web Workers的未来"></a>25.6.4 Web Workers的未来</h4><h3 id="25-1-小结"><a href="#25-1-小结" class="headerlink" title="25.1 小结"></a>25.1 小结</h3><h2 id="附录A-ECMAScript-Harmony"><a href="#附录A-ECMAScript-Harmony" class="headerlink" title="附录A ECMAScript Harmony"></a>附录A ECMAScript Harmony</h2><h2 id="附录B-严格模式"><a href="#附录B-严格模式" class="headerlink" title="附录B 严格模式"></a>附录B 严格模式</h2><h2 id="附录C-JavaScript库"><a href="#附录C-JavaScript库" class="headerlink" title="附录C JavaScript库"></a>附录C JavaScript库</h2><h2 id="附录D-JavaScript工具"><a href="#附录D-JavaScript工具" class="headerlink" title="附录D JavaScript工具"></a>附录D JavaScript工具</h2>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
